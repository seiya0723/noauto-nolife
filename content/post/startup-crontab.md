---
title: "cronの基本的な使い方と活用例について"
date: 2018-12-09T16:10:13+09:00
draft: false
thumbnail: "images/20181206003.jpg"
categories: [ "command" ]
tags: [ "スタートアップシリーズ","cron", "定時処理", "作業効率化","自動化","システム管理" ]
---

<p>指定した時刻になったらコマンドを自動的に実行してくれるのがcronです。デーモンとして稼働するので作業の邪魔にならず、管理者権限が必要なコマンドであっても問題なく利用できるので非常に便利です。</p>

<ul>
<li><a href="#chapter1">cronについての概要</a></li>
<li><a href="#chapter2">crontabの使い方</a></li>
<li><a href="#chapter3">活用例</a></li>
<li><a href="#chapter4">結論</a></li>
</ul>

<h2 id="chapter1">cronについての概要</h2>

<h3>cronとは</h3>

<p>先述の通り、cronは時間とコマンドを指定することによって、バックグラウンドで自動的に処理を行うことができるデーモンプロセスです。</p>

<p>指定した時刻にコマンドを実行してほしいとき、あるいは指定した時間毎に繰り返しコマンドを実行してほしい場合に利用します。</p>

<h3>cronのインストールについて</h3>

<p>cronはほぼ全てのLinuxにデフォルトでインストールされています。Debian系OSであれば下記のコマンドを実行して、cronがインストールされていることを確認してみましょう。</p>

<pre><code>dpkg -l cron</code></pre>

<p>すると以下の実行結果が出力されます。</p>

<div class="img-center"><img src="/images/20181206001.jpg" alt="インストールされているパッケージ一覧からcronを表示させた結果の画像" /></div>

<p>このように表示されればcronがインストールされていることがわかります。もし、cronがインストールされていない場合は、以下のコマンドを実行してインストールさせましょう。</p>

<pre><code>sudo apt install cron</code></pre>

<h3>cronの構成について</h3>

<p>cronは以下のファイルとディレクトリで構成されています。これらのファイルやディレクトリが保管されているパスは<code>/etc/</code>です。</p>

<div class="img-center"><img src="/images/20181206002.jpg" alt="cronの構成ファイルとディレクトリ" /></div>

<h4>cron.d、cron.daily、cron.hourly、cron.weekly、cron.monthly</h4>

<p>これらは、それぞれのディレクトリにファイルを入れることで定期的に実行できます。<code>cron.d</code>は拡張子のないファイルを保管する際に使用します。</p>

<p><code>cron.daily</code>、<code>cron.hourly</code>、<code>cron.weekly</code>、<code>cron.monthly</code>はそれぞれの時間毎に実行するようになっています。例えば<code>cron.daily</code>であれば一日ごとにコマンドを実行できます。</p>

<p>ただし、後述の<code>crontab</code>ファイルを書き換えれば事は足りるので、あえてこれらの設定を変更する必要は無いでしょう。</p>

<h4>crontab</h4>

<p><code>crontab</code>に設定を書き込むことによって、コマンドを指定した時間毎に実行できます。1分単位で指定できるので、1分ごとにコマンドを繰り返し実行したりすることも可能です。月や日、曜日まで指定できるのでかなり自由度は高いと言えるでしょう。</p>

<h3>anacronとcronの違いについて</h3>

<p>cronと似たパッケージにanacronというものがありますが、anacronはcronとは違います。</p>

<p>anacronはシステムが連続で動作することを前提としていない作りになっています。例えば、1日に1回実行する操作がcronに設定されていた場合、システムがダウンしてしまうと復帰した後から指定した操作が1回ごと実行されるようになります。しかし、anacronの場合は、復帰した後から指定した操作が実行できなかった回数だけ反復して実行させるのです。</p>

<div class="img-center"><img src="/images/20181206003.jpg" alt="anacronは停止中に実行できなかった回数だけ実行する" /></div>

<p>上記の図のようにanacronはシステムが復帰したときに、システム停止中に実行できなかった回数だけ操作を行います。</p>

<p>他にも、anacronは最小の単位が1日なので、1日の間に特定の操作を何回も実行したい場合には不向きである点に注意しましょう。</p>

<h2 id="chapter2">crontabの使い方</h2>

<h3>cronの基本的な使い方</h3>

<p>それでは実際にcronを使ってみましょう。cronの操作に必要なファイル操作はcrontabだけで十分です。下記のコマンドを入力します。</p>

<pre><code>sudo vi /etc/crontab</code></pre>

<p>するとvimが起動してファイルの中身が表示されます。</p>

<div class="img-center"><img src="/images/20181206004.jpg" alt="crontabの中身" /></div>

<p>書式は簡単で右側から、分（minnute）、時間（hour）、日（day of monthly）、月（monthly）、曜日（day of weekly）、実行するユーザー（user）、コマンド（command）で指定します。例えば毎週月曜日の15時25分にユーザー名servermanで<code>mkdir /home/serverman/testdirectory</code>を実行して欲しいときには以下のように記述します。</p>

<pre><code>25 15 * * 1 serverman mkdir /home/serverman/testdirectory</code></pre>

<p>こうすることで毎週月曜日の15時25分に<code>mkdir</code>が実行され<code>/home/serverman/</code>の配下に<code>testdirectory</code>という名前のディレクトリが生成されます。曜日の指定は、日曜日が0と7で土曜日が6、月曜日が1、火曜日が2です。</p>

<p>管理者権限が必要なコマンドはrootユーザーを指定します。例えば毎日午前0時に<code>shutdown</code>コマンドを実行して再起動したい場合はこのように記入します。</p>

<pre><code>0 0 * * * root shutdown -r now</code></pre>

<p>コマンドの指定は絶対パスでも利用可能です。<code>shutdown</code>コマンドであれば<code>/sbin/</code>の配下にあるので、以下のような指定でも同じように動作します。</p>

<pre><code>0 0 * * * root /sbin/shutdown -r now</code></pre>

<h3>標準出力されるコマンドやプログラムの対処法</h3>

<p><code>echo</code>コマンドや<code>df</code>コマンドなどのシェルに標準出力するタイプのコマンドやプログラムについては注意が必要です。何も指定していない状態だと処理結果はシェルに表示されないので、別途メールの指定が必要になります。</p>

<pre><code>MAILTO="test@example.com"</code></pre>

<p>これをPATHの下辺りに指定しておけば、標準出力された内容がメールになって届きます。もしメールを送信したくない場合は下記のように書き換えておきましょう。</p>

<pre><code>MAILTO=""</code></pre>

<p>メールが利用できない場合は、処理結果をリダイレクトすることでファイルに書き込むことができます。試しに以下の内容を<code>crontab</code>に追記してみましょう。ユーザー名のservermanは各自で変更してください。</p>

<pre><code>*/1 * * * * serverman echo "hello" >> /home/serverman/crontest.txt</code></pre>

<p>これは1分経つ毎に<code>crontest.txt</code>に処理結果であるhelloを追記していくことを意味しています。よって数分後には、/home/serverman/crontest.txtの中身がこんなふうになっています。</p>

<div class="img-center"><img src="/images/20181206005.jpg" alt="cronで標準出力の処理結果をリダイレクトした" /></div>

<p>このまま放置すると<code>crontest.txt</code>がどんどん肥大化していくので、先程の定時処理は忘れずに削除しておきましょう。</p>

<h3>エラーも出力したい場合</h3>

<p>ファイルなどに処理結果をリダイレクトしたいことがあります。しかしリダイレクトされる内容は標準出力だけで標準エラー出力は無視されてしまいます。特に自作のプログラムでは保守に関わるので、差し支えなければ標準エラー出力もリダイレクトしたいところです。</p>

<p>そんなときには下記の内容を末尾に入力してエラーも同時に出力するようにしましょう。</p>

<pre><code>2>&1</code></pre>

<p>これは標準エラー出力も標準出力にリダイレクトするという意味を持っています。つまりこの文字列を末尾に入力するだけで、標準エラー出力も標準出力の一部として取り扱われるのです。</p>

<p>試しにエラーのあるプログラムのソースコードを作ってコンパイルさせましょう。そのコンパイルの結果をてきとうなテキストファイルにリダイレクトさせます。</p>

<div class="img-center"><img src="/images/20181206006.jpg" alt="普通に標準エラー出力をテキストファイルにリダイレクトしても反映されない" /></div>

<p>リダイレクト先のテキストファイルに標準エラー出力がリダイレクトされていません。そこで先程の標準エラー出力を標準出力として取り扱う文字列を末尾に入力します。そうすると、このような結果になりました。</p>

<div class="img-center"><img src="/images/20181206007.jpg" alt="標準エラー出力を標準出力に変換してリダイレクトすると反映される" /></div>

<p>以上の点を踏まえて、先程の1分ごとに<code>echo</code>コマンドを実行する場合、標準エラーもリダイレクト先のテキストファイルに書き込んで欲しいときにはこうします。</p>

<pre><code>*/1 * * * * serverman echo "hello" >> /home/serverman/crontest.txt 2>&1</code></pre>

<p>こうすることで<code>echo</code>コマンドに何らかの標準エラーが発生した場合は、それらも含めてリダイレクト先のテキストファイルにリダイレクトされるようになります。</p>

<p>繰り返しになりますが、この定時処理を削除しないと1分毎に<code>crontest.txt</code>が肥大化していくので確認した後は削除しておきましょう。</p>

<h3>エラーだけをリダイレクトしたい場合</h3>

<p>上記の場合は標準エラー出力と標準出力を一緒にしていましたが、単に標準エラー出力だけをファイルにリダイレクトしたい場合は以下のようにします。</p>

<pre><code>*/1 * * * * serverman echo "hello" 2>> /home/serverman/crontest.txt</code></pre>

<p>こうすることで、エラーが発生したらcrontest.txtに追記されるようになり、標準出力されるhelloはシェルに表示されるようになります。標準エラー出力の回収は保守の際にも役立つでしょう。</p>

<h2 id="chapter3">活用例</h2>

<p>cronの活用例は非常に多いです。以下の内容は氷山の一角であり、アイデア次第で何にでも利用できます。</p>

<h3>シャットダウン</h3>

<p>夜中にサーバーにアクセスしないのであれば、電気代の無駄になってしまうので節電のためにもシャットダウンしておきましょう。</p>

<code>shutdown</code>コマンドは管理者権限が必要になるので実行ユーザーの指定は<code>root</code>になります。

<pre><code>0 0 * * * root shutdown -h now</code></pre>

<p>これで毎日午前0時になったら自動的にシャットダウンされ、電源が切れるようになります。</p>

<h3>定時でソフトウェアの更新</h3>

<p>ソフトウェアの更新を怠ってしまうことがあります。特にサーバーの場合はTera TermなどでSSHでリモートログインした後、実行しなければならないので面倒です。</p>

<p>そこで定期的にソフトウェアの更新を行うようにcronで設定しましょう。debian系OSであれば<code>apt</code>コマンドでソフトウェアの更新ができます。ただし、こちらも<code>shutdown</code>コマンドと同様に管理者権限が必要です。</p>

<pre><code>30 22 * * * root apt update && apt -y upgrade && apt -y autoremove</code></pre>

<p>これで毎日22時30分にパッケージリストの更新、更新のインストール、不要なパッケージの自動削除ができます。</p>

<h3>ファイルのアクセス履歴の確認</h3>

<p>対象のファイルへのアクセス履歴を確認することができれば、情報漏えいやインシデント発生時のヒントになるでしょう。しかし、大抵ログが消去されているものです。だから定期的に履歴を確認しておくことで対策できます。</p>

<p>ファイルのアクセス履歴の確認にはfindコマンドを活用すれば良いでしょう。例えば今日アクセスしたファイルの一覧を出力したい場合には以下のように入力します。</p>

<pre><code>0 0 * * * root find [検索したいパス] -atime -1</code></pre>

<p>こうすることで、毎日0時になると、今日の0時から24時間前の昨日の0時までの間にアクセスされたファイルがまとめて表示されます。アクセス履歴ではなく、更新されたファイルの一覧を出力したい場合はこうします。</p>

<pre><code>0 0 * * * root find [検索したいパス] -mtime -1</code></pre>

<p>これで今日の0時から24時間前までの昨日の0時までに更新されたファイルのリストが一覧になって出力されます。</p>

<h3>ディスク使用量の確認</h3>

<p>ディスクにデータを格納し続けていくと、いずれ空き領域が少なくなってしまいます。放置しておくとデータが保管できなくなってしまうので、予めデータの使用量を確認して使用量が多ければ増設させます。</p>

<p>ディスク使用量の確認は<code>df</code>コマンドを使用すれば問題ありません。</p>

<pre><code>0 0 * * * root df -h --total</code></pre>

<p>これでマウントされている全てのディスクの使用量と空き領域を調べて、更に合計値まで分かりやすく出力させることができます。</p>

<h3>ファイルパーミッションの検索結果の確認</h3>

<p>ファイルサーバーやウェブサーバーなど不特定多数の利用者と共有するサーバーの中に、フルアクセス可能なファイルが存在すると、それが原因で不正アクセスの被害に発展してしまう可能性もあります。</p>

<p>しかし不正なパーミッションのファイルを手動で探していくのは面倒です。そこでこれもcronで定期的に実行してしまいましょう。<code>find</code>コマンドを使用すれば簡単です。</p>

<pre><code>0 0 * * * root find [検索したいパス] -perm 777 -ls</code></pre>

<p>指定したパーミッションに一致しないファイルは評価式<code>-not</code>と<code>-type</code>を活用します。</p>

<pre><code>0 0 * * * root find [検索したいパス] -type f -not -perm 644 -ls</code></pre>

<h3>空ディレクトリの確認</h3>

<p>空ディレクトリが増えすぎてしまうと、ファイルの捜索が面倒になってしまいます。<code>find</code>コマンドが利用できれば、それなりに早く探索できますがそれでも面倒であることに変わりはありません。</p>

<p>だから、対象ディレクトリの中にある空ディレクトリを定期的に探して確認しましょう。</p>

<pre><code>0 0 * * * root find [検索したいパス] -empty -ls</code></pre>

<h3>サイズの大きいファイルの確認</h3>

<p>サーバー内にサイズの大きいファイルが複数存在していると、ディスク使用量が増えてしまい結果的に新しいディスクを購入しなければなりません。</p>

<p>経費削減のためにも定期的にサイズの大きいファイルをリスト化して確認しておくことが重要です。こちらも<code>find</code>コマンドで問題なく検索できます。</p>

<pre><code>0 0 * * * root find [検索したいパス] -size +1G -ls</code></pre>

<p>これで1GBを超えるファイルの一覧が表示できます。</p>

<h3>ウェブスクレイピングプログラムの実行</h3>

<p>ウェブスクレイピングプログラムは多大なリソースとネットワークの帯域を使用するものです。だからこそ夜中に実行して負荷を分散させましょう。</p>

<p>また、自作のウェブスクレイピングプログラムはエラーによって異常終了してしまう可能性も考えられるので、保守をしやすくするためにも標準エラー出力を標準出力として取り扱うことが重要です。</p>

<pre><code>0 0 * * * serverman /home/serverman/webscraper.pyc >> scraperlog.txt 2>&1</code></pre>

<p>それから、ウェブスクレイピングプログラムは朝になっても処理が終わらないこともあるので、プログラム側から朝になったらプロセスを一時的に中断するなどの措置を施しておくと良いでしょう。検索対象を格納したテキストファイルを検索が完了する毎に編集すれば、次回の起動でも途中から実行できます。</p>

<h3>脆弱性の検査、セキュリティチェック</h3>

<p>脆弱性の検査は定期的に行うべきですが、仕事で忙しいと忘れてしまいます。サーバーに脆弱性が存在しているにもかかわらず、修正されずに放置されてしまうとリスクに繋がるので、脆弱性の検査もcronで定時処理をしましょう。</p>

<p>脆弱性の検査やセキュリティチェックなどであれば、Rootkit HunterやVuls、lynisにclam antivirusなどのパッケージを使います。</p>

<h3>データのバックアップ</h3>

<p>RAID1でミラーリングを行っていない場合は、手動でデータのバックアップを行わなければなりません。しかし、定期的にバックアップを取るべきだと分かっていても忘れてしまうものです。だからこそ、cronで定期的にバックアップを取らせるようにしましょう。</p>

<h2 id="chapter4">結論</h2>

<p>時間や曜日、日付を指定して繰り返し処理を実行する。cronは単純な仕組みですが汎用性が高く、アイデア次第で何にでも応用ができて、管理者権限でも動作するので非常に強力です。</p>

<p>メール送信機能を活用して手元のスマートフォンやスマートウォッチに定時処理の結果を知らせることもできます。cronはサーバーの管理を行うときには必ずと言っていいほど使うことになるので覚えておくと作業が大幅に捗るでしょう。</p>

