<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Django on 自動化無しに生活無し</title>
    <link>https://noauto-nolife.com/tags/django/</link>
    <description>Recent content in Django on 自動化無しに生活無し</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 21 Oct 2021 07:25:39 +0900</lastBuildDate>
    
	<atom:link href="https://noauto-nolife.com/tags/django/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【Django】canvasで描画した画像をAjax(jQuery)で送信【お絵かきBBS、イラストチャット、ゲームのスクショ共有などに】</title>
      <link>https://noauto-nolife.com/post/django-canvas-send-img-by-ajax/</link>
      <pubDate>Thu, 21 Oct 2021 07:25:39 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-canvas-send-img-by-ajax/</guid>
      <description>例えば、チャットサイト、掲示板サイトでユーザーが描画したイラストを投稿できる形式にしたい時。 ユーザーが手元の端末でペイントツールを起動して画像を保存して、サイトに添付して貼り付けるのはやや面倒。それだけでなく、サイト独自のレギュレーション(お題に沿ってイラストを付け加える形式、指定された色しか使ってはいけないなど)がある場合、ユーザーのペイントツールでそれを強いるのは不可能に近い。 そこで、サイト上</description>
    </item>
    
    <item>
      <title>Djangoで投稿したデータに対して編集・削除を行う</title>
      <link>https://noauto-nolife.com/post/django-models-delete-and-edit/</link>
      <pubDate>Sun, 17 Oct 2021 10:44:55 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-delete-and-edit/</guid>
      <description>40分簡易掲示板を元に、forms.pyにてモデルを継承したフォームクラスを作り、その上で削除と編集を実装させる。 前提(forms.pyにてモデルを継承したフォームクラスを作る) モデルを継承したフォームクラスの作り方は『【Django】forms.pyでバリデーションをする【モデルを継承したFormクラス】』を参照。 bbs/forms.pyを作る。内容は下記。 from django import forms from .models import Topic class TopicForm(forms.ModelForm): class Meta: model = Topic fields = [ &amp;quot;comment&amp;quot;</description>
    </item>
    
    <item>
      <title>【Django】要素数が同じモデルオブジェクトをDTLで一緒にループして表示させる【.annotate()やモデルクラスにメソッドを追加などが通用しない場合の対策】</title>
      <link>https://noauto-nolife.com/post/django-model-objects-for-in-zip/</link>
      <pubDate>Wed, 13 Oct 2021 15:22:14 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-model-objects-for-in-zip/</guid>
      <description>例えば、マイリストフォルダに保存されている、マイリスト動画。マイリストフォルダの一覧を表示している時に、フォルダ内の動画のサムネイル1つを表示させたい時、どうやって再現させましょうかと言うのが今回の課題。 こういう時は、zipとlistを使用して対処する他に、生成されたモデルオブジェクトを加工することで対処する。 この方法を使えば、複雑なORMを考えたり、モデルクラスにメソッドを追加したりするなどを考</description>
    </item>
    
    <item>
      <title>【Django】テンプレートからstaticディレクトリに格納したCSSやJSを読み込む【静的ファイル】</title>
      <link>https://noauto-nolife.com/post/django-static-file-settings/</link>
      <pubDate>Mon, 11 Oct 2021 15:03:30 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-static-file-settings/</guid>
      <description>Djangoビギナーが40分で掲示板アプリを作る方法では、Bootstrapのみ使用している。オリジナルの装飾を施したい場合、Djangoの静的ファイルの読み込みを使用するしか方法はない。 本記事では予め作っておいたCSSやJS等のファイルを読み込みする方法を記す。 settings.pyにて読み込みのパスを設定 settings.pyの末端にて、STATICFILES_DIRSを追加する。 # Static files (CSS, JavaScript, Images)</description>
    </item>
    
    <item>
      <title>Djangoで管理サイトを作る【admin.py】</title>
      <link>https://noauto-nolife.com/post/django-admin/</link>
      <pubDate>Tue, 05 Oct 2021 07:34:27 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin/</guid>
      <description>Djangoではデフォルトで管理サイトというものが用意されている。 admin.pyに少し書き足して、管理ユーザーを作成するコマンドを打つだけで、簡単にデータの読み書きが実現できる。 ソースコードは40分Djangoから流用する。 admin.pyの編集 bbs/admin.pyを開いて下記のように編集する。 from django.contrib import admin from .models import Topic admin.site.register(Topic) モデルクラス、Topicをインポートして、adminに登録(register)す</description>
    </item>
    
    <item>
      <title>【Django】models.pyにフィールドを追加・削除する【マイグレーションできないときの原因と対策も】</title>
      <link>https://noauto-nolife.com/post/django-models-add-field/</link>
      <pubDate>Tue, 05 Oct 2021 06:45:55 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-add-field/</guid>
      <description>models.pyを操作していく上で難しいのが、フィールドの追加とマイグレーション。 特に、追加するフィールドによってはマイグレーションファイル作成時に警告が出ることがある。 本記事では警告が出る理由も含め、フィールドの追加方法も含めて解説する。ソースコードはDjangoビギナーが40分で掲示板アプリを作る方法を元にする。 デフォルト値ありのフィールドを追加する まず、安全なデフォルト値ありのフィールドを</description>
    </item>
    
    <item>
      <title>DjangoでHTTPリクエストのPOSTメソッドを送信する</title>
      <link>https://noauto-nolife.com/post/django-post-request/</link>
      <pubDate>Mon, 04 Oct 2021 07:54:13 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-post-request/</guid>
      <description>DjangoでHelloWorld【HttpResponse及びレンダリング】にて、HelloWorldをやった人向け。本記事はビュークラスとテンプレートを使用した場合を想定して解説する。 DjangoでHTTPリクエストのPOSTメソッドを送信する。これにより、データをリクエストボディに含ませることが可能になり、HTTPSを実装すれば投稿内容の暗号化も可能になる。 手順 views.pyのビュークラス</description>
    </item>
    
    <item>
      <title>Djangoでスクレイピング対策をする【MIDDLEWAREでUA除外、ランダムでHTML構造変化等】</title>
      <link>https://noauto-nolife.com/post/django-anti-scraping/</link>
      <pubDate>Sat, 02 Oct 2021 19:05:06 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-anti-scraping/</guid>
      <description>最近ではPythonのスクレイピング関係の書籍が増えてきて、誰でも簡単にスクレイピングできるようになってきている。 その影響か、私が管理しているサイトもしょっちゅうスクレイピングかと思われるアクセスがログから確認できる。 放置しているとさらにエスカレートし、ただの負荷にしかならないので、スクレイピングには対策が必要。本記事では、とりわけ私の得意なDjangoでその方法を記す。 MIDDLEWAREにPy</description>
    </item>
    
    <item>
      <title>Djangoで任意のHTTPレスポンス(ForbiddenやNotFoundなど)を返却する【HttpResponse subclasses】</title>
      <link>https://noauto-nolife.com/post/django-http-response/</link>
      <pubDate>Sat, 02 Oct 2021 18:56:03 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-http-response/</guid>
      <description>あまり需要が無いかも知れないが、状況によっては手動でHTTPResponseを指定して返却したい場合もあるだろう。 本記事ではよく使用すると思われるレスポンスをまとめる。 HttpResponseBadRequest from django.http import HttpResponseBadRequest from django.views import View class BbsView(View): def get(self, request, *args, **kwargs): return HttpResponseBadRequest(&amp;quot;bad&amp;quot;) index = BbsView.as_view() リクエストの一部が欠落している場合など、クライアント側のエラーに表示させる。 HttpResponseNotFound from django.http import HttpResponseNotFound from django.views import View class BbsView(View): def get(self, request, *args, **kwargs): return HttpResponseNotFound(&amp;quot;not found&amp;quot;) index = BbsView.as_view() 引数内に入れた内容をクライアントのブラウザにHTMLとして表示させる コ</description>
    </item>
    
    <item>
      <title>【Django】Heroku&#43;Cloudinaryの環境にアップロードしたファイルを参照する方法【MIMEとサイズ】</title>
      <link>https://noauto-nolife.com/post/django-deploy-heroku-cloudinary-file-reference/</link>
      <pubDate>Wed, 29 Sep 2021 15:45:48 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-heroku-cloudinary-file-reference/</guid>
      <description>クライアントがアップロードしたファイルをビュー側で参照するときがある。例えば、許可されていないMIMEのアップロード、ファイルサイズの確認など。 通常であれば、下記のようにすれば良い。 request.FILES[&amp;quot;document&amp;quot;] しかし、こんな参照をすると、Cloudinaryにはアップロードできてもファイルが壊れてしまう。PDF等の普通のファイルであれば問題はないが、mp4等の動画ファイルで発生している模様。 コード POSTメソッドだけ掲載。</description>
    </item>
    
    <item>
      <title>【Django】forms.pyでバリデーションをする【モデルを継承したFormクラス】</title>
      <link>https://noauto-nolife.com/post/django-forms-validate/</link>
      <pubDate>Wed, 29 Sep 2021 09:16:49 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-forms-validate/</guid>
      <description>『Djangoビギナーが40分で掲示板アプリを作る方法』で作った簡易掲示板はクライアントから受け取った値のチェックを行っていない。 モデルでは投稿できるコメントは2000文字以内であり。入力必須となっているが、開発用のSQLiteはそこまで判定できない。故にこういうことが起こる。 MySQLやPostgreSQL等の本番用のDBではDBが直接エラーを出す仕組みになるが、それでは使用しているDBが何かク</description>
    </item>
    
    <item>
      <title>DjangoをHeroku&#43;Cloudinary(基本無料ストレージ)の環境にデプロイする【ウェブアプリのデモを一般公開したい場合などに】</title>
      <link>https://noauto-nolife.com/post/django-deploy-heroku-cloudinary/</link>
      <pubDate>Sat, 25 Sep 2021 10:34:37 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-heroku-cloudinary/</guid>
      <description>Herokuにはクレジットカードを登録することで、Cloudinaryというアドオンを利用することができる。これがHerokuのストレージとして運用可能。 一部はDjangoをDEBUG=FalseでHerokuにデプロイする方法と内容が重複しているため、そちらを読んだ人向けに書く。 アップロードするコードはDjangoで画像及びファイルをアップロードする方法より流用。テンプレートのsrc属性、hre</description>
    </item>
    
    <item>
      <title>【Django】デプロイ後に管理サイトを管理者以外がアクセスできないようにする【UUID&#43;MIDDLEWAREによるURL複雑化とIPアドレス制限】</title>
      <link>https://noauto-nolife.com/post/django-admin-protect/</link>
      <pubDate>Wed, 22 Sep 2021 21:55:24 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-protect/</guid>
      <description>Djangoの管理サイトのURLはデフォルトでは、admin/となっている。そのため、誰でも簡単に管理サイトにアクセスできる。しかもIDとパスワードのフォームしか表示されていないので、総当りすればいずれ突破されてしまう。 だからこそ、アクセス制限と推測されないURLというものが重要になってくる。本記事ではなるべくシステムに依存せず、Djangoのみで管理サイトの保護が完結する方法を記す。 方法論 以下の</description>
    </item>
    
    <item>
      <title>リモートサーバーのデータを自動的にバックアップする方法論【scp&#43;crontab】</title>
      <link>https://noauto-nolife.com/post/shellscript-auto-backup/</link>
      <pubDate>Sun, 19 Sep 2021 18:12:35 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/shellscript-auto-backup/</guid>
      <description>手順 crontabを使って、一定時間おきにリモートサーバーがバックアップを取る crontabを使って、一定時間おきに任意の端末がscpでリモートサーバーのバックアップファイルをDL crontabを使って、一定時間おきにリモートサーバーがバックアップしたデータを削除 方法 例えば、Djangoであればこうなる。 リモートサーバーの/etc/crontabに以下の設定を施す。 00 * * * * ubuntu cd ~/Document/django/ &amp;amp;&amp;amp; python3 manage.py dumpdata [任意の</description>
    </item>
    
    <item>
      <title>【Django】settings.pyのSECRET_KEYを再発行(リジェネレート)する【alias登録で即生成・即実装からの再起動】</title>
      <link>https://noauto-nolife.com/post/django-secret-key-regenerate/</link>
      <pubDate>Fri, 17 Sep 2021 11:19:11 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-secret-key-regenerate/</guid>
      <description>うっかり、SECRET_KEYをバージョン管理対象に含ませてしまった。このままではクラウドサーバーにデプロイしたSECRET_KEYが予測され、CSRFトークン等が機能不全になってしまう。 そんな時に備えておきたい、SECRET_KEYの再発行の方法を解説する。 ソースコード Qiitaより拝借。 from django.core.management.utils import get_random_secret_key secret_key = get_random_secret_key() text = &#39;SECRET_KEY = \&#39;{0}\&#39;&#39;.format(secret_key) print(text) 実行すると、 SECRET_KEY = &#39;07y^y0#_7b74jy)d6z0lu5*r$#azfyt1*1f+g1-3w+l@&amp;amp;hs^2!&#39; 等の文言が出てくる。 aliasに登録して、どこでも再発行できるよ</description>
    </item>
    
    <item>
      <title>【Django&#43;Sendgrid】サーバー処理中(ビュー、独自コマンド)に通知メール(To,CC,BCC)を送信する</title>
      <link>https://noauto-nolife.com/post/django-sendgrid-processing/</link>
      <pubDate>Wed, 15 Sep 2021 07:48:47 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-sendgrid-processing/</guid>
      <description>DjangoでSendgridを実装させる方法【APIキーと2段階認証を利用する】で解説したとおり、SendgridのAPIキーをsettings.pyに書けばallauthでメール送信ができる。 だが、サーバーの処理中(ビューやmanage.py系の独自コマンド)でメールを送信するにはsettings.pyのメール設定を読み込む必要がある。 ソースコード まず、前回と同様にsettings.pyにてA</description>
    </item>
    
    <item>
      <title>【形態素解析】DjangoとJUMAN&#43;&#43;を使ってトレンドワード(名詞のみ)を表示する【定期実行で1時間以内に投稿された内容を学習などに】</title>
      <link>https://noauto-nolife.com/post/django-jumanpp-trend/</link>
      <pubDate>Mon, 13 Sep 2021 19:42:36 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-jumanpp-trend/</guid>
      <description>Djangoの独自コマンドの作成とAIを組み合わせることで、ウェブアプリ上でAIの恩恵を受けることができる。 とりわけ自然言語処理関係であれば、日本語の知識さえあれば簡単に試すことができるだろう。 本記事では形態素解析ツールとして名高い京都大学のJUMANをDjango上で動かし、その結果をウェブページとして表示させる。 作り方 モデルを作る トピックモデルとトレンドモデルの2つを作る。 from django.db import models from django.utils import timezone class Topic(models.Model):</description>
    </item>
    
    <item>
      <title>【Django&#43;AWS】独自ドメインを割り当てHTTPS通信を実現した状態で、EC2(Ubuntu&#43;Nginx)へデプロイする</title>
      <link>https://noauto-nolife.com/post/django-deploy-ec2-origin-domain/</link>
      <pubDate>Mon, 13 Sep 2021 08:19:27 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-ec2-origin-domain/</guid>
      <description>既に、【AWS】EC2にムームドメインで取得した独自ドメインを割り当て、HTTPS通信を行う【Route 53 + Certificate Manager + ロードバランサ(ELB)】の内容を終え、独自ドメインでHTTPS通信が可能な状態である前提で解説する。 一部、DjangoをAWSのEC2(Ubuntu)にデプロイすると内容が重複しているが、AWS側の設定は一切行わない。書き換えが必要なのは、settings.pyのALLOWED_HO</description>
    </item>
    
    <item>
      <title>DjangoでサイトにアクセスしたクライアントのIPアドレス、ユーザーエージェント(UA)、プロバイダ名(ゲートウェイ名)を表示する【犯罪・不正行為の抑止とセキュリティ】</title>
      <link>https://noauto-nolife.com/post/django-show-ip-ua-gateway/</link>
      <pubDate>Mon, 13 Sep 2021 07:21:22 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-show-ip-ua-gateway/</guid>
      <description>不正行為や犯罪などの抑止力として効果を発揮する、クライアントのUA、IPアドレス及びプロバイダ名の表示。その方法をここに記す。 グローバルIPアドレスを表示 ビュー側で以下のように取得する。 ip_list = request.META.get(&#39;HTTP_X_FORWARDED_FOR&#39;) if ip_list: ip = ip_list.split(&#39;,&#39;)[0] else: ip = request.META.get(&#39;REMOTE_ADDR&#39;) もし、ip_listに記録されたIPアドレスが複数ある場合は、ネットワーク構成などを考慮して添字を指定する。 ユーザーエージェント(UA)を表示 ビュー側で以下のように取得する。 user_agent = request.META.get(&#39;HTTP_USER_AGENT&#39;) リクエスト</description>
    </item>
    
    <item>
      <title>【Django】SQLiteでも特定フィールドに対してのdistinctっぽい事(重複除去)を行う【通常はPostgreSQLのみ有効】</title>
      <link>https://noauto-nolife.com/post/django-distinct-on-sqlite/</link>
      <pubDate>Fri, 10 Sep 2021 11:21:51 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-distinct-on-sqlite/</guid>
      <description>以下のクエリはPostgreSQLのみ有効。 Topic.objects.all().distinct(&amp;quot;comment&amp;quot;) このように.disitinct()に引数としてフィールド名を指定できるのは、PostgreSQLだけ。.values()を使う方法もあるが、モデルオブジェクトでなくなる時点で汎用性に乏しい。 そこで、重複するフィールドを除外したいのであれば、こうする。 topics = Topic.objects.all().order_by(&amp;quot;-dt&amp;quot;) d_list = [] n_list = [] for t in topics: if t.comment in d_list: continue d_list.append(t.comment) n_list.append(t) context[&amp;quot;topics&amp;quot;] = n_list これで重複するコメントを除外して新しいモデルオブジェクトの</description>
    </item>
    
    <item>
      <title>【Django】カスタムテンプレートタグ(フィルタ)でリンク付きのハッシュタグを実現する。【#から始まる正規表現】</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags-hashtags/</link>
      <pubDate>Sun, 05 Sep 2021 17:30:49 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags-hashtags/</guid>
      <description>Djangoのカスタムテンプレートタグ(フィルタ)を使うことでTwitterやyoutube等のハッシュタグを実現できる。 だが、ちょっとでも間違えると、簡単にXSS脆弱性を生み出してしまう可能性があるため、十分注意して実装する。 方法論 まず、普通のDTLはXSS対策のため、&amp;lt;や&amp;gt;等の特殊記号をエスケープしている。ハッシュタグを実現させるのであれば、まずはこれを除外する。そのため、mark</description>
    </item>
    
    <item>
      <title>【Django】kwargsを使ってビューを使いまわす【urls.py&#43;views.py】</title>
      <link>https://noauto-nolife.com/post/django-args-kwargs-view-recycle/</link>
      <pubDate>Thu, 02 Sep 2021 19:20:58 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-args-kwargs-view-recycle/</guid>
      <description>kwargsを使うことで似たような処理のビューを使いまわしできる。これによりビューのコード行数を大幅に削減可能。 状況 例えば、私のブログのように、記事一覧や記事本文を表示する左側のメインエリア、カテゴリやタグなどを表示するサイドエリア、2つのエリアがあったとする。 つまり、カテゴリやタグなどの情報は常に表示し、URLによってメインエリアの情報を切り替えたい場合、urls.pyはどうなるだろうか？ すぐに</description>
    </item>
    
    <item>
      <title>【Django】実行されるクエリを確認する【.query】</title>
      <link>https://noauto-nolife.com/post/django-models-query/</link>
      <pubDate>Thu, 02 Sep 2021 13:20:50 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-query/</guid>
      <description>備忘録として。複雑なORMになった時、クエリを確認する時は、末尾に.query属性を使う。print文で出力できる。 print(Topic.objects.all().query) #出力結果 SELECT &amp;quot;topic&amp;quot;.&amp;quot;id&amp;quot;, &amp;quot;topic&amp;quot;.&amp;quot;comment&amp;quot; FROM &amp;quot;topic&amp;quot; 表示はされるものの、SQLが最適化されているわけではない点に注意。あくまでも挙動がおかしいときの確認用として。 【補足】生のSQLを実行する 出力した生のSQLを少しいじって実行させることもできる。SQLの末尾を示す;は不要。 Topic.objects.raw(&amp;quot;SELECT * FROM topic&amp;quot;) SQLインジェクションには十分注</description>
    </item>
    
    <item>
      <title>【Django】Windowを使ってレコードの累計値を計算して出力【売上の累計表示、小計(累積)表示などに有効】</title>
      <link>https://noauto-nolife.com/post/django-models-window/</link>
      <pubDate>Wed, 01 Sep 2021 18:23:58 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-window/</guid>
      <description>日付でソートして売上を表示するとして、その日付になるまでの累計(累積)売上金額を表示したいとする。 そういう時はWindowを使えば、累計(累積)値を表示させることができる。 ソースコード 前回の月ごとに売上を表示するコードから流用。ビューとテンプレートの処理だけ書き換える。 from django.db.models import Sum,Window,F menus = Menu.objects.annotate(accumulate=Window(Sum(&amp;quot;amount&amp;quot;), order_by=[ F(&amp;quot;date&amp;quot;).desc(),F(&amp;quot;id&amp;quot;).asc() ] ) ).values(&amp;quot;id&amp;quot;,&amp;quot;name&amp;quot;,&amp;quot;date&amp;quot;,&amp;quot;amount&amp;quot;,&amp;quot;accumulate&amp;quot;).order_by(&amp;quot;-date&amp;quot;,&amp;quot;id&amp;quot;) 累積計算時(Windowの中)のorder_byとvaluesを実行した後のorder_byは揃えなければ</description>
    </item>
    
    <item>
      <title>【Django】年、月、日単位でデータをファイリングする時はTruncを使用する【月ごとの売上、個数などの出力に有効】</title>
      <link>https://noauto-nolife.com/post/django-models-trunc/</link>
      <pubDate>Wed, 01 Sep 2021 17:39:04 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-trunc/</guid>
      <description>ブログなどでよくある、月別アーカイブ。経理でよくある、月ごとの売上記録、年ごとの収支。そういった計算をする時、annotateとTruncを使えば1行で出力できる。 ソースコード モデルがこんな感じ。 from django.db import models class Menu(models.Model): class Meta: db_table = &amp;quot;menu&amp;quot; name = models.CharField(verbose_name=&amp;quot;メニュー名&amp;quot;,max_length=2000) date = models.DateField(verbos</description>
    </item>
    
    <item>
      <title>【Django】MIDDLEWAREを作って、常にデータを表示する【requestにモデルオブジェクトを属性として追加する】</title>
      <link>https://noauto-nolife.com/post/django-create-middleware-add-request-attribute/</link>
      <pubDate>Sun, 29 Aug 2021 20:56:46 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-create-middleware-add-request-attribute/</guid>
      <description>例えば、サイトのどのページにアクセスしても表示させたいデータがあるとしよう。サイトのトップバーあたりにサイトの更新履歴(ニュース)のようなものをスライドして表示させたい時などがそうだ。サイトのニュースだから当然、誰でも見れる仕組みにする。 こういうどのページでも常時表示しなければならないデータがある時、いかにして手を打つか。当然、更新履歴は管理サイトから追加していくものだから、モデルを参照しなければ</description>
    </item>
    
    <item>
      <title>【Django】MIDDLEWAREを自作、未ログインユーザーにメディアファイルへのアクセスを拒否する【settings.py】</title>
      <link>https://noauto-nolife.com/post/django-create-middleware/</link>
      <pubDate>Sat, 28 Aug 2021 17:17:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-create-middleware/</guid>
      <description>未ログインユーザーに対して動画や画像等のメディアファイルは公開したくない。しかし、何も対策をしていないとメディアファイルは誰でも見放題の状態になってしまう。 たとえそれが有料コンテンツであったとしても、mp4やpngのリンクを直接アクセスするだけで誰でも見れる。これではユーザーは離反する。 そこで、どんなリクエストでも必ず通るDjangoのMIDDLEWAREを利用する。本記事ではMIDDLEWARE</description>
    </item>
    
    <item>
      <title>【Django】同一人物による工作(再生数の水増しなど)をいかにして防ぐか、方法と対策【unique_together,Recaptcha,UA,IPアドレス等】</title>
      <link>https://noauto-nolife.com/post/django-same-user-operate-prevent/</link>
      <pubDate>Thu, 26 Aug 2021 12:24:05 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-same-user-operate-prevent/</guid>
      <description>例えば、動画サイトを運営していて、動画の再生回数を記録する機能を実装したとする。 動画の検索で、再生数の多い順に並び替えて表示する機能が既にある場合、再生回数の水増しによって、全く面白くない動画が検索の上位に表示されるなどの問題が発生する。 それだけでなく、再生回数の水増しを放置してしまうと、ランキングも荒れ果て、結果的にユーザーが離反してしまう恐れもある。(※ただし、ランキングの集計方法によってある</description>
    </item>
    
    <item>
      <title>Djangoで中間テーブルありの多対多フィールドを使用したモデルに良いね・悪いねする【related_nameとカスタムユーザーモデル】</title>
      <link>https://noauto-nolife.com/post/django-m2m-through-good-bad/</link>
      <pubDate>Tue, 24 Aug 2021 13:03:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-through-good-bad/</guid>
      <description>状況 以前作った、【Django】Reverse accessor for &amp;lsquo;Topic.good&amp;rsquo; clashes with reverse accessor for &amp;lsquo;Topic.user&amp;rsquo;.というエラーの対処【Topicに対する良いね、多対多中間フィールドあり】では、モデルはできあがっているものの、肝心のトピックに良いね悪いねするビューの処理、テンプレートの描画までは解説していない。 そこで、今回はトピックに良いね悪いねをする方法を解説する。 bbs/models.pyとuse</description>
    </item>
    
    <item>
      <title>【Django】Reverse accessor for &#39;Topic.good&#39; clashes with reverse accessor for &#39;Topic.user&#39;.というエラーの対処【Topicに対する良いね、多対多中間フィールドあり】</title>
      <link>https://noauto-nolife.com/post/django-m2m-through-reverse-accessor-error/</link>
      <pubDate>Thu, 19 Aug 2021 10:41:05 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-through-reverse-accessor-error/</guid>
      <description>このエラーが発生する状況がやや複雑なので、状況から解説。 このエラーが起こる状況 まず、カスタムユーザーモデルを実装している。 モデルの中身は【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】から丸ごと流用。 そして、アプリのモデル。簡易掲示板に良いねと悪いね機能を実装している。 多対多の中間テーブルを手動で定義している。詳細は【django</description>
    </item>
    
    <item>
      <title>FormDataをformタグではなく、オブジェクトにキーと値をセットした上でAjax送信</title>
      <link>https://noauto-nolife.com/post/javascript-formdata-obj-set/</link>
      <pubDate>Sat, 14 Aug 2021 11:48:15 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/javascript-formdata-obj-set/</guid>
      <description>タイトルの説明。 通常、Ajaxでサーバーにリクエストを送信する時、下記のようにFormDataクラスを使用して送信する。 let form_elem = &amp;quot;#form_area&amp;quot;; let data = new FormData( $(form_elem).get(0) ); let url = $(form_elem).prop(&amp;quot;action&amp;quot;); let method = $(form_elem).prop(&amp;quot;method&amp;quot;); $.ajax({ url: url, type: method, data: data, processData: false, contentType: false, dataType: &#39;json&#39; }).done( function(data, status, xhr ) { //Done }).fail( function(xhr, status, error) { //Fail }); しかし、送信したいデータがいつもこのようにformタグで囲まれているとも限らない。 そこで、FormDataクラスに引数を入れずにオブジェクトを作り、オブジェクトにキーと値をセットしてAja</description>
    </item>
    
    <item>
      <title>Djangoのモデルに独自メソッドを追加、テンプレートに表示【フィールド間の計算、他モデルの値の表示などに有効】</title>
      <link>https://noauto-nolife.com/post/django-models-add-method-template-attribute/</link>
      <pubDate>Sat, 07 Aug 2021 16:28:40 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-add-method-template-attribute/</guid>
      <description>モデルにメソッドを追加することで、テンプレート側から属性値として参照することができる。 from django.db import models class Topic(models.Model): class Meta: db_table = &amp;quot;topic&amp;quot; comment = models.CharField(verbose_name=&amp;quot;コメント&amp;quot;,max_length=2000) time = models.IntegerField(verbose_name=&amp;quot;活動時間(分)&amp;quot;,default=0) level = models.Integer</description>
    </item>
    
    <item>
      <title>DjangoでDBへデータ格納時(save)、削除時(delete)に処理を追加する【models.py、forms.py、serializer.pyのメソッドオーバーライド】</title>
      <link>https://noauto-nolife.com/post/django-models-save-delete-override/</link>
      <pubDate>Sat, 07 Aug 2021 16:20:24 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-save-delete-override/</guid>
      <description>例えば、クライアントがお問い合わせフォームに入力して送信した時、DBに内容を保存すると同時に管理者に内容をメールで送信したい。そんなことは無いだろうか？ しかも、その保存のビューの処理が各所に分散していて、一つ一つ書いていくのが面倒な時。こういう時はモデルクラスのsaveメソッドを書き換える(オーバーライドする)ことで対処できる。 オーバーライドの方法 公式からコードを拝借。 models.pyにて、下記</description>
    </item>
    
    <item>
      <title>Djangoで数値型もしくはUUID型等のフィールドに、クライアント側から未入力を許可するにはnull=Trueとblank=Trueのオプションを</title>
      <link>https://noauto-nolife.com/post/django-models-uuid-int-null/</link>
      <pubDate>Sat, 07 Aug 2021 10:53:38 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-uuid-int-null/</guid>
      <description>タイトルの通り。 基本的な話として、blankとは空文字列のこと。だから文字列型扱いになる。一方でnullはPythonで言うとNoneであり、型は無い。 よってblank=Trueのフィールドオプションが許されるのは、CharField等の文字列型系のフィールドのみで、IntegerFieldやUUIDFieldには許されない。 と思われがちだが、それは半分誤解である。実は下記の指定は正しい。 dt = mo</description>
    </item>
    
    <item>
      <title>Djangoでマイグレーションした時、『Auto-created primary key used when not defining a primary key type』と警告される場合の対策</title>
      <link>https://noauto-nolife.com/post/django-models-autofield-warnings/</link>
      <pubDate>Sat, 31 Jul 2021 20:15:18 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-autofield-warnings/</guid>
      <description>マイグレーションした時、下記のようなエラーが出る。 これは主キーを定義せず、自動的に作っているからである。 対策は下記をsettings.pyに追加するだけ。 DEFAULT_AUTO_FIELD=&#39;django.db.models.AutoField&#39; 結論 主キーをUUIDにしている場合、発生しない警告文である。 Django-allauth等のDjango用のライブラリを使っている場合も、ライブラリの中にモデルが埋まっており、対策をしない限り、このような警告文が出る。 参照元 https://stackoverflow.com/questions/66971594/auto-create-primary-key-used-when-not-defining-a-primary-key-type-warning-in-dja</description>
    </item>
    
    <item>
      <title>Djangoで主キーのリスト型を作り、合致するレコードを検索する【values_list &#43; filter】</title>
      <link>https://noauto-nolife.com/post/django-id-list-filter/</link>
      <pubDate>Sat, 31 Jul 2021 16:36:00 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-id-list-filter/</guid>
      <description>例えば、複数のレコードのIDを検索して削除したい場合、下記のように記述する。 result = Topic.objects.filter(id__in=[1,2,3]) print(result) #idが1,2,3のデータが表示される。 これがリスト型のIDを使用したIN句である。 ちなみに、検索結果からIDのリストを作るには、下記のようにする。 result = list(Topic.objects.all().values_list(&amp;quot;id&amp;quot;,flat=True)) print(result) #[1, 2, 3, 4, 5, 6, 7, 8] idだけカラムを指定し、flat=Trueとすることで数値型のリストを作ることができる。 参照元 https://docs.djangoproject.com/en/3.2/ref/models/querysets/#in https://docs.djangoproject.com/en/3.2/ref/models/querysets/#values-list</description>
    </item>
    
    <item>
      <title>Djangoで複数の外部キーに対応したフィールドの個数をカウントする【annotate(Count)&#43;DISTINCT】</title>
      <link>https://noauto-nolife.com/post/django-foreign-count-distinct/</link>
      <pubDate>Sat, 31 Jul 2021 16:30:47 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-foreign-count-distinct/</guid>
      <description>【Django】外部キーに対応したデータの個数をカウントして表示【リプライ・コメント数の表示に有効】【annotate+Count】から annotateで外部キーで繋がっているコメント数をカウントしてフィールドを追加するには下記のようにすれば良い。 from django.db.models import Count Video.objects.annotate( num_comments=Count(&amp;quot;videocomment&amp;quot;) ).all().order_by(&amp;quot;-dt&amp;quot;) Countの第一引数に外部キーで繋がっているモデルクラスの小文字を文字列型で指定する。 しかし、マイリスト数、良いねの数など複数の外部キーで</description>
    </item>
    
    <item>
      <title>DjangoをS3(AWS)ストレージ付きのHerokuにデプロイする</title>
      <link>https://noauto-nolife.com/post/django-deploy-heroku-s3/</link>
      <pubDate>Sat, 31 Jul 2021 15:59:46 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-heroku-s3/</guid>
      <description>Herokuで画像などのファイルをアップロードしたい時、別途ストレージを用意する必要がある。 特に代表的なのがAWSのS3をストレージとする方法。 既に解説記事があるので、S3の設定関係はDjangoをEC2(Ubuntu)、RDS(PostgreSQL)、S3の環境にデプロイをするを参照。 コードはDjangoで画像及びファイルをアップロードする方法から流用する。 Herokuデプロイの詳しい流れは、D</description>
    </item>
    
    <item>
      <title>Djangoの管理サイトのフォームをカスタムする【forms.py】</title>
      <link>https://noauto-nolife.com/post/django-admin-custom-form/</link>
      <pubDate>Sat, 31 Jul 2021 15:57:27 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-custom-form/</guid>
      <description>管理サイトのフォームはとりわけ何もしなければ、registerするモデルフィールドに依存する。 つまり、CharFieldの場合、inputタグtype=&amp;quot;text&amp;quot;が自動的に管理画面のフォームに挿入される。 そのため、何もしなければフィールドオプションがmax_length=2000でも1行のテキストボックスでしか入力できない。 改行もできなければ全体を確認することも困難な管理画面</description>
    </item>
    
    <item>
      <title>DjangoをEC2(Ubuntu)、RDS(PostgreSQL)、S3の環境にデプロイをする</title>
      <link>https://noauto-nolife.com/post/django-deploy-ec2-rds-s3/</link>
      <pubDate>Mon, 26 Jul 2021 17:59:20 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-ec2-rds-s3/</guid>
      <description>DjangoをAWSのEC2(Ubuntu)にデプロイするの続編。EC2にデプロイした後、RDS、S3を使って、さらに大型のウェブアプリを動作させる。 本記事ではRDS(PostgreSQL)、S3のセットアップを中心に解説をする。基本的なEC2へのデプロイの流れは上記記事を確認するべし。 RDS(PostgreSQL)の設定 流れ ダッシュボードからRDSのインスタンス生成 セキュリティグループの設定(E</description>
    </item>
    
    <item>
      <title>DjangoをAWSのEC2(Ubuntu)にデプロイする</title>
      <link>https://noauto-nolife.com/post/django-deploy-ec2/</link>
      <pubDate>Sun, 18 Jul 2021 09:45:32 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-ec2/</guid>
      <description>Herokuとは違ってサーバーが日本にもあり、なおかつ課金すれば大型のウェブアプリでもインターネット上に公開できる、それがAWS。 本記事ではAWSのEC2を使用し、画像アップロード可能な簡易掲示板をデプロイ工程を解説する。 デプロイ対象のコード ソースコードは以下。 https://github.com/seiya0723/django_fileupload 作り方は下記を参照。 Djangoで画像及びファイルをアップロードする方法 必要なもの クレジットカード AWSアカウント Djangoのsett</description>
    </item>
    
    <item>
      <title>【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-allauth-bbs/</link>
      <pubDate>Tue, 22 Jun 2021 08:46:59 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-allauth-bbs/</guid>
      <description>手元のディレクトリ内で雛形が分散していたので、自分用に作った。 コードは40分Django簡易掲示板から。allauthはsettings.pyにID認証を、ユーザーモデルはDjangoのGitHubから何も書き加えていないモデルをそのまま流用した。 雛形をすぐにDLして書き換えができるようにGitHubに公開する。 users/models.py ほぼ流用。Handle_nameは元のfirst_nameとlast_nameに分割</description>
    </item>
    
    <item>
      <title>【Django】カスタムユーザーモデルでユーザーブロック機能を実装させる【ManyToManyFieldでユーザーモデル自身を指定】</title>
      <link>https://noauto-nolife.com/post/django-m2m-usermodel/</link>
      <pubDate>Mon, 21 Jun 2021 21:36:59 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-usermodel/</guid>
      <description>本格的にSNS等のサービスを運用する時、必要になるのがユーザーフォロー(友達)やユーザーブロックの機能。理論上、いずれもユーザーとユーザーを多対多でつなぐことで実現できる。 今回はユーザーブロックの機能をカスタムユーザーモデルを使って再現する。 コードは【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】から流用している。 ユーザーモデル u</description>
    </item>
    
    <item>
      <title>【django】ManyToManyFieldでフィールドオプションthroughを指定、中間テーブルを詳細に定義する【登録日時など】</title>
      <link>https://noauto-nolife.com/post/django-m2m-through/</link>
      <pubDate>Mon, 21 Jun 2021 16:57:08 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-through/</guid>
      <description>多対多のフィールドは、複数から1つを選ぶ1対多よりも使う機会が多いだろう。 飲食店が提供するメニューの食品アレルギー指定、複数のユーザーに対する通知、ユーザーに対するフォローやブロックの機能など。 DjangoではManyToManyFieldを定義した時、中間テーブルは自動的に作られる。そのため、そのままでは中間テーブルにレコードが挿入された時間などが記録できない。 自分で中間テーブルの中身を作りたい</description>
    </item>
    
    <item>
      <title>【Django】views.pyの事前処理 VS (埋め込み型)カスタムテンプレートタグ・フィルタ</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags-vs-before-view-calc/</link>
      <pubDate>Tue, 15 Jun 2021 03:08:14 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags-vs-before-view-calc/</guid>
      <description>思考停止状態でカスタムテンプレートタグを作っているとき、ふと気づいた。 『これ、views.pyで事前に処理をしたほうが良いのではないか』と。 考察に至った背景 カスタムテンプレートタグは基本的にviews.pyがレンダリングをする段階で動作する。 つまりそれは、クライアントにレスポンスが届く直前であり、サーバーサイドが介入できる最後の処理である。 故に、『カスタムテンプレートタグを実行した後に、任意の処理</description>
    </item>
    
    <item>
      <title>【Django】admin.pyからカスタムアクションを追加し、管理サイトから実行【crontab、BaseCommandが使えない場合の対処法】</title>
      <link>https://noauto-nolife.com/post/django-admin-custom-action/</link>
      <pubDate>Mon, 14 Jun 2021 17:33:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-custom-action/</guid>
      <description>【Django】manage.pyコマンドを追加させる【バッチ処理、常駐プログラムなどに】から、manage.pyのコマンドを追加することができる。 だが、誰もがmanage.pyのコマンドを実行できるとも限らない。crontabが使えない場合もある。 特にコマンドを打ったことのない人向けにシステムの管理を行ってもらう場合、GUIで操作できる管理サイトからアクションを追加する方法が妥当と言えよう。 そこ</description>
    </item>
    
    <item>
      <title>Djangoの管理サイト(admin)をカスタムする【全件表示、全フィールド表示、並び替え、画像表示、検索など】</title>
      <link>https://noauto-nolife.com/post/django-admin-custom/</link>
      <pubDate>Thu, 10 Jun 2021 12:30:46 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-custom/</guid>
      <description>admin.pyはとても便利ではあるが、ただのadmin.site.register([モデルクラス])ではとても使いづらい。 特にそのままでは管理サイト内で画像を取り扱ったり、複数のデータを参照したり、検索や絞り込みしたりすることはできない。 そこで、管理サイトをカスタマイズして使いやすくさせる。 コード 元コードは、Djangoで画像及びファイルをアップロードする方法から流用した。以下のようにmode</description>
    </item>
    
    <item>
      <title>【Django】allauthのurls.pyをカスタムする【新規アカウント作成、パスワード変更処理の無効化など】</title>
      <link>https://noauto-nolife.com/post/django-allauth-custom-urls/</link>
      <pubDate>Tue, 25 May 2021 09:49:51 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-allauth-custom-urls/</guid>
      <description>Django-allauth。とても便利ではあるが、運用する場所によっては必要のない処理も含まれている。 例えば、新規アカウント作成の処理。これは限られた人間しかアクセスを許されないサイト(例:社員用のウェブアプリ等)の場合、部外者が勝手にアカウントを作り、内部へのアクセスを許してしまう。 そこで、新規アカウント作成処理やパスワード変更処理などを無効化させる。そのためには、allauthのurls.p</description>
    </item>
    
    <item>
      <title>【Django】バッチ処理でPS、AI(PDF)ファイルのサムネイルを自動生成させる【BaseCommand】</title>
      <link>https://noauto-nolife.com/post/django-batch-thumbnail-create/</link>
      <pubDate>Sun, 23 May 2021 12:02:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-batch-thumbnail-create/</guid>
      <description>PS、AIファイルのサムネイルを作る処理をmanage.pyコマンドに追加することで、ビューの負担を軽減する。 これにより、負荷のかかる処理をビューから分離できる。投稿処理が集中しても、高負荷の処理が原因でサーバーダウンすることは無いのだ。 全体像 こんなふうに、通常のリクエストで行われる処理系とは分離して、サムネイルの自動生成が行われる。 ループにより逐次処理を行うため、リクエストとは違って並列ではない</description>
    </item>
    
    <item>
      <title>【Django】16進カラーコードから色名に書き換えるフィルタを自作する【カスタムテンプレートフィルタ】</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags-color/</link>
      <pubDate>Wed, 12 May 2021 17:35:56 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags-color/</guid>
      <description>models.pyにて、色の指定を16進数のカラーコードで受け入れる。その16進数カラーコードを、色名(orangeとかforestgreenとか)に書き換える。 そういうカスタムテンプレートフィルタを自作する方法を解説する。 models.pyのカラーコード受け入れ from django.db import models from django.core.validators import RegexValidator &amp;quot;&amp;quot;&amp;quot; 省略 &amp;quot;&amp;quot;&amp;quot; color_regex = RegexValidator(regex=r&#39;^#(?:[0-9a-fA-F]{3}){1,2}$&#39;) color = models.CharField(verbose_name=&amp;quot;リボン色&amp;quot;,max_</description>
    </item>
    
    <item>
      <title>Djangoでアップロードされた.aiと.psファイルのサムネイルを自動生成させる【PhotoShop,Illustrator】</title>
      <link>https://noauto-nolife.com/post/django-aips-thumbnail-autocreate/</link>
      <pubDate>Mon, 10 May 2021 10:01:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-aips-thumbnail-autocreate/</guid>
      <description>ファイルをアップロードした後、ファイル名だけ表示されている状態では、それが何なのかパット見でよくわからない。 だからこそ、事前にサムネイルを用意させる。こんなふうに だが、サムネイル画像のアップロードまでユーザーに押し付けるのは、気軽なファイル共有を前提としたウェブアプリのコンセプトが台無しになる。そこで、アップロードしたファイルのサムネイルをサーバーサイドに自動生成してもらう。 本記事ではファイルアッ</description>
    </item>
    
    <item>
      <title>【django.core.paginator】一度に2ページ以上ジャンプできるように改良する【inclusion_tag()】</title>
      <link>https://noauto-nolife.com/post/django-paginator-custom/</link>
      <pubDate>Fri, 07 May 2021 09:50:13 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-paginator-custom/</guid>
      <description>以前のページネーション実装記事では、検索とページのパラメーターの両立を行った。 しかし、このページネーションは1ページずつしか移動できない。つまり、1ページ目の状態から2ページ目に行くことはできても、3ページ目にジャンプすることはできないのだ。 そこでページネーションを改良させ、一度に2ページ以上ジャンプできるように改良する。 やりたいことと方法論の解説 やりたいこと 要するに、本記事でやりたいのはこういう</description>
    </item>
    
    <item>
      <title>Djangoでviews.pyからmodels.pyのフィールドオプションを参照する【verbose_name,upload_to】</title>
      <link>https://noauto-nolife.com/post/django-reference-models-option/</link>
      <pubDate>Tue, 04 May 2021 20:30:19 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-reference-models-option/</guid>
      <description>需要ないかもだけど、備忘録として。 Video.thumbnail.field.upload_to つまり、 [モデルクラス].[フィールド名].field.[フィールドオプション] これで参照できる。 用途 FileFieldでアップロードした動画のサムネイル(ImageField)をviews.pyが自動生成する時、アップロード先のパスを指定する必要があるが、models.pyのフィールドオプションとして書いたupload_toと整合性を合わせるために、本記事で扱</description>
    </item>
    
    <item>
      <title>Djangoでmakemigrationsコマンドを実行しても、No changes detectedと言われる場合の対処法</title>
      <link>https://noauto-nolife.com/post/django-makemigrations-not-applied/</link>
      <pubDate>Wed, 28 Apr 2021 15:00:56 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-makemigrations-not-applied/</guid>
      <description>Djangoでマイグレーションファイルを作る python3 manage.py makemigrations このコマンドを実行しても返ってくるのが、 No changes detected とされ、マイグレーションファイルが作られないことがある。当然この状態でmigrateコマンドを打ってもDBには反映されない。 そこで、本記事ではこの対処法について列挙する。 対処法1:settings.pyのINSTALLED_APPSに対象のアプリを追加 python3 manage.py makemigrations python3 manage.py migrate この2つのコマンドを打って、models</description>
    </item>
    
    <item>
      <title>【Slack風】モーダルダイアログ無し、ページ遷移無しで編集フォームを作る【JS不使用】</title>
      <link>https://noauto-nolife.com/post/nomodal-edit-form/</link>
      <pubDate>Sun, 25 Apr 2021 13:42:24 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/nomodal-edit-form/</guid>
      <description>投稿されたコンテンツを編集する時、編集フォームを表示するページに遷移したり、編集フォームをJSなどを使用してモーダルダイアログとして表示させることがある。こんなふうに。 しかし、これでは他のコンテンツを見ながらの編集ができない。それだけでなく、ページ遷移やダイアログ表示を行うとJSやサーバーサイドに負担がかかる。そこで、投稿したコンテンツを表示する場所を、編集フォームに切り替えるように仕立てる。こん</description>
    </item>
    
    <item>
      <title>Djangoのforms.pyが提供するフォームテンプレートは使わない</title>
      <link>https://noauto-nolife.com/post/django-forms-temp-not-use/</link>
      <pubDate>Tue, 13 Apr 2021 21:32:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-forms-temp-not-use/</guid>
      <description>Djangoのforms.pyはユーザーから受け取った値のバリデーションだけでなく、フォームのテンプレートも提供してくれる。(widgetを使うなどしてクラス名やHTMLタグの指定ができる) しかし、私はこのforms.pyの提供するフォームのテンプレートは使わない。本記事ではその理由を列挙する 理由1:フロントサイドとサーバーサイドの分業問題 そもそも、テンプレートの開発はフロントサイド開発者のするこ</description>
    </item>
    
    <item>
      <title>【Django】バッチ処理のOpenCVが撮影した画像をDBに保存する</title>
      <link>https://noauto-nolife.com/post/django-batch-opencv/</link>
      <pubDate>Tue, 16 Mar 2021 16:15:03 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-batch-opencv/</guid>
      <description>Djangoのバッチ処理を実行し、DBにデータを格納させる。ただし、OpenCVで撮影した画像をDBに保存させる。本記事ではその手順を記す。 実行環境・やりたいこと 実行環境 Django 2.2以上 Ubuntu 18.04 やりたいこと 流れはだいたいこんな感じ OS起動時、バッチ処理がCrontabから実行される バッチ処理はOpenCVを使用し、撮影した画像を保存 保存した画像とコメントをDBに記録 1秒経ったら、2に戻る つまり、コマ撮りし</description>
    </item>
    
    <item>
      <title>Djangoで動画投稿時にサムネイルもセットでアップロードする【DRF&#43;Ajax(jQuery)&#43;canvas】</title>
      <link>https://noauto-nolife.com/post/django-ajax-thumbnail-upload/</link>
      <pubDate>Mon, 01 Mar 2021 15:03:31 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax-thumbnail-upload/</guid>
      <description>Djangoで動画をアップロードする時、ffmpegなどを使ってサムネイルの自動生成を行うが、クライアントが自分で動画のサムネイルを指定したいときはこの限りではない。 サムネイルに指定したい画像は動画内にあり、クライアントがサムネイルの画像をまだ作っていない場合、アップロードフォームでサムネイルを作る必要がある。 本記事では動画を投稿する際、サムネイルをクライアントが指定した上でアップロードする手法を</description>
    </item>
    
    <item>
      <title>Djangoでカスタムユーザーモデルを外部キーとして指定する方法</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-foreignkey/</link>
      <pubDate>Sat, 20 Feb 2021 11:13:37 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-foreignkey/</guid>
      <description>例えば、簡易掲示板で投稿者のユーザーIDを外部キーとして指定したい場合がある。 作ったカスタムユーザーモデルを外部キーとして通常のアプリから指定する方法を解説する。 カスタムユーザーモデルを外部キーとして指定する まず、settings.pyに下記のような設定がされているとする。usersアプリのCustomUserクラスを指定している。 AUTH_USER_MODEL = &#39;users.CustomUser&#39; 続いて、任意のアプリのモデルを編集する。 from django.db import models from django.utils import timezone from django.conf</description>
    </item>
    
    <item>
      <title>【AWS】Cloud9使う時にすぐやる設定【bashrc、Django等】</title>
      <link>https://noauto-nolife.com/post/cloud9-first-config/</link>
      <pubDate>Tue, 16 Feb 2021 09:42:06 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/cloud9-first-config/</guid>
      <description>Cloud9を使う時にやっておく設定をまとめる。 注意事項としてAWS、Cloud9はいずれも頻繁にバージョンアップを行っている仕様上、ここに書かれている情報では再現できない可能性がある。もし、Cloud9のバージョンアップによる不具合や動作不良などを気にされる場合は、ローカル環境に開発環境を構築すると良い。 Bashの設定関係 コマンド履歴に日時を表示させる ~/.bashrcを下記のように編集する。 export</description>
    </item>
    
    <item>
      <title>DjangoでUUIDを主キーとしたカスタムユーザーモデルを作る【AbstractBaseUserとallauth】</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-uuid/</link>
      <pubDate>Mon, 15 Feb 2021 15:47:57 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-uuid/</guid>
      <description>Djangoでユーザーを作ったとき、デフォルトでは数値型オートインクリメントの主キーになる。 身内だけで使う小さなウェブアプリであれば大した問題にはならないと思うが、基本主キーが数値型かつオートインクリメントであれば、簡単に予測されてしまう。セキュリティリスクは最小限に留めるためにも、なるべく主キーはUUID型にしたい。 そこで、本記事ではユーザーの主キーにUUIDを使用したカスタムユーザーモデルの作</description>
    </item>
    
    <item>
      <title>DjangoでSendgridを実装させる方法【APIキーと2段階認証を利用する】</title>
      <link>https://noauto-nolife.com/post/django-sendgrid/</link>
      <pubDate>Fri, 12 Feb 2021 17:48:49 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-sendgrid/</guid>
      <description>Sendgridのパスワードを使用したメール送信が廃止され、APIを使用した2段階認証が強制されるため、ここに対策を記す。本記事はDjango(Python)を対象とした対策について解説する。 django-sendgrid-v5のインストール APIを使用するために、pipにてdjango-sendgrid-v5をインストールさせる。 pip install django-sendgrid-v5 settings.pyにて設定を施す settings.pyの</description>
    </item>
    
    <item>
      <title>【Django】manage.pyコマンドを追加させる【バッチ処理、常駐プログラムなどに】</title>
      <link>https://noauto-nolife.com/post/django-command-add/</link>
      <pubDate>Mon, 01 Feb 2021 18:25:13 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-command-add/</guid>
      <description>Djangoのmanage.pyにはコマンドを追加することができる。これを利用すれば、アプリディレクトリで定義したモデルをそのまま流用してDBにアクセスしたり、コマンド一発で複雑な処理を終わらせたり、バッチ処理として運用させることも簡単にできる。 manage.pyにコマンドを追加させる まず、任意のアプリディレクトリにmanagement/commands/ディレクトリを作る。 mkdir -p [アプリディレクト</description>
    </item>
    
    <item>
      <title>DjangoやPythonにおける*argsと**kwargsとは何か</title>
      <link>https://noauto-nolife.com/post/django-args-kwargs/</link>
      <pubDate>Tue, 26 Jan 2021 17:07:45 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-args-kwargs/</guid>
      <description>結論から言うと、*argsはキーワード未指定の引数のリスト、**kwargsはキーワードが指定された引数の辞書を手に入れるためのものである。 *argsはキーワード未指定の引数のリスト まずは、下記コードを参考にしたい。 #! /usr/bin/env python3 # -*- coding: utf-8 -*- import sys def main(name,*args): print(name) print(args) if __name__ == &amp;quot;__main__&amp;quot;: try: main(&amp;quot;Tom&amp;quot;,&amp;quot;Mike&amp;quot;,&amp;quot;Bob&amp;quot;) except KeyboardInterrupt: print(&amp;quot;\nprogram was ended.\n&amp;quot;) sys.exit() main()関数に3つの文字列の引数を与えている。&amp;quot;Tom&amp;quot;,&amp;quot;Mike&amp;quot;,&amp;quot;Bo</description>
    </item>
    
    <item>
      <title>【Django】外部キーに対応したデータの個数をカウントして表示【リプライ・コメント数の表示に有効】【annotate&#43;Count】</title>
      <link>https://noauto-nolife.com/post/django-foreign-count/</link>
      <pubDate>Tue, 26 Jan 2021 17:02:16 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-foreign-count/</guid>
      <description>例えば、Djangoで掲示板サイトを作り、投稿した内容に対してリプライできる機能を付けたとする。そのリプライ数を一覧表示時に合わせて表示させる時、どうする？ 本記事では、上記のように一対多のリレーションが構築されている環境下で、多に該当するデータ数を計算して表示させる方法を解説する。 多のデータ数を計算してそれぞれ表示させる 下記のような、Topicに対してReplyができるモデルになっていたとする。 from</description>
    </item>
    
    <item>
      <title>【Django】モデルフィールドに正規表現によるバリデーションを指定する【カラーコード・電話番号に有効】</title>
      <link>https://noauto-nolife.com/post/django-models-regex-validate/</link>
      <pubDate>Tue, 26 Jan 2021 16:40:18 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-regex-validate/</guid>
      <description>例えば、Djangoで電話番号や16進数カラーコード、郵便番号や金融機関コードなどの、桁数と使用文字の種類が決まったデータをモデルフィールドに挿入する時、どうしていますか？ CharFieldやIntegerFieldにそのまま入れる？フロント側で対策しているから大丈夫？そんなわけない。不適切なデータがDBに入った時点で、システムは破綻する。それは世の常。 そこで、本記事ではモデルに正規表現のバリデー</description>
    </item>
    
    <item>
      <title>【django-cleanup】画像等のファイルを自動的に削除する</title>
      <link>https://noauto-nolife.com/post/django-cleanup/</link>
      <pubDate>Tue, 26 Jan 2021 16:18:42 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-cleanup/</guid>
      <description>例えば、Djangoの画像掲示板で削除をする時、ビューでレコードを削除すると同時に、レコードに紐付いた画像も同時に削除すると思う。その時、パスを抜き取り、os.remove()などを使用して画像を削除しているようでは、ビューの処理がどんどん増えていく。 Djangoでは、レコードに紐付いたファイルの削除処理記述の手間を減らしてくれるdjango-cleanupなるものがある。本記事ではその使用方法を</description>
    </item>
    
    <item>
      <title>Djangoで埋め込みカスタムテンプレートタグを実装する方法</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags/</link>
      <pubDate>Tue, 26 Jan 2021 15:55:04 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags/</guid>
      <description>Djangoでデータの値に応じて文字列を返したい場合は、カスタムテンプレートタグを使用すれば良い。下記記事は、ページ移動と検索を両立させるため、文字列を返す、カスタムテンプレートタグを実装している。 Djangoでページネーションを実装する方法【django.core.paginator】【パラメータ両立】 しかし、データの値に応じてHTMLタグを返却するには、上記の方法では成立しない。safeフィル</description>
    </item>
    
    <item>
      <title>Django Templates Language(DTL)でincludeを実行する時に引数も与える</title>
      <link>https://noauto-nolife.com/post/django-templates-include/</link>
      <pubDate>Thu, 24 Dec 2020 16:51:03 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-templates-include/</guid>
      <description>Djangoでテンプレートファイルを分離させ、includeするときがある。複数の箇所で同じフォームを表示したりする時がそうだ。 ただ、フォームのIDをそれぞれの箇所で別々とする場合、引数を指定する必要がある。 結論 結論から言うと、こうなる。 {% include &amp;quot;[パス]&amp;quot; with [引数名]=[値] %} includeするhtmlのパスを指定した後、withを指定することで引数の指定が可能になる。指定した引</description>
    </item>
    
    <item>
      <title>Djangoでデフォルト数値型のid(主キー)からUUID型にする【データ移行】</title>
      <link>https://noauto-nolife.com/post/django-id-to-uuid/</link>
      <pubDate>Thu, 24 Dec 2020 16:42:59 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-id-to-uuid/</guid>
      <description>PostgreSQL等のDBサーバーで、1対多等のリレーションを組んだウェブアプリを作る時、Djangoのデフォルトの数値型のidではエラーが出てしまう。つまり、UUIDの使用は不可避。 しかし、既にデータがいくらか存在しているため、DB内のデータを全削除してUUIDにマイグレーションし直すのは不可能。困った。 こういう、数値型の主キーが割り当てられた既存データを保持したまま、UUID型の主キーに書き</description>
    </item>
    
    <item>
      <title>Djangoにカスタムユーザーモデルを実装させる【AbstractUserとallauth】</title>
      <link>https://noauto-nolife.com/post/django-allauth-custom-user-model/</link>
      <pubDate>Mon, 14 Dec 2020 16:28:15 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-allauth-custom-user-model/</guid>
      <description>Djangoでカスタムユーザーモデルを実装すれば、ユーザーが会員登録をする時、IDとパスワードだけでなく、ファーストネームや年齢、職業なども入力させた上で会員登録を行うことができる。 これにより、会員登録した後、データ投稿時にユーザー情報もセットで挿入できる。未指定でログイン可能な会員になってしまうという問題を防ぐことができる。 ただ、カスタムユーザーモデルの実装は容易ではない。カスタムユーザーモデル</description>
    </item>
    
    <item>
      <title>Djangoで多対多のリレーションを含むデータをAjax(jQuery)&#43;DRFで送信させる</title>
      <link>https://noauto-nolife.com/post/django-m2m-restful/</link>
      <pubDate>Tue, 01 Dec 2020 17:17:52 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-restful/</guid>
      <description>本記事では多対多のリレーションを含んだウェブアプリで、Django REST FrameworkとAjaxを使用した非同期データ送信を実現させる方法を書く。 ソースコードは『【Django】一対多、多対多のリレーションでforms.pyを使ったバリデーションとフォームを表示』の『【2】forms.pyを使用したフォームバリデーション+独自に作ったテンプレート』から流用した。 Ajax(jQuery)+Restf</description>
    </item>
    
    <item>
      <title>DRF(Django REST Framework)&#43;Ajax(jQuery)で画像とファイルをアップロードする方法</title>
      <link>https://noauto-nolife.com/post/drf-ajax-fileupload/</link>
      <pubDate>Tue, 01 Dec 2020 17:06:20 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/drf-ajax-fileupload/</guid>
      <description>本記事では、DRF(Django REST Framework)とAjaxを使用して画像とファイルを非同期でアップロードする方法をまとめる。 コードはDjangoで画像及びファイルをアップロードする方法から引用している。外見はほとんど変わっていない。 テンプレートとJSのコード まずテンプレート。下記はimage.html {% load static %} &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt; &amp;lt;title&amp;gt;画像アップロードのテスト&amp;lt;/ti</description>
    </item>
    
    <item>
      <title>【Django】一対多、多対多のリレーションでforms.pyを使ったバリデーションとフォームを表示</title>
      <link>https://noauto-nolife.com/post/django-m2m-form/</link>
      <pubDate>Tue, 01 Dec 2020 16:03:44 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-form/</guid>
      <description>本記事ではDjangoで一対多、多対多のリレーションを実装した上で、forms.pyを使用し、フォームをバリデーションする。 また、単にforms.pyからフォームのテンプレートを作るだけでなく、複数指定が要求されるフォームの作り方についても解説する。 コードはDjangoで多対多のリレーションをテンプレートで表示する方法【ManyToManyField】から流用。 【1】forms.pyを使用したフォ</description>
    </item>
    
    <item>
      <title>Djangoで多対多のリレーションをテンプレートで表示する方法【ManyToManyField】</title>
      <link>https://noauto-nolife.com/post/django-many-to-many/</link>
      <pubDate>Fri, 27 Nov 2020 17:20:39 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-many-to-many/</guid>
      <description>多対多のリレーションを作って、いざ表示させようとした時、普通に{{ content.allergy }}などと指定してしまうとこうなってしまう。 表示できていない。正しく指定するとこうなる。 コードの解説 結論から言うと、テンプレートでの表示に問題がある。下記のようにすると表示できる。 &amp;lt;td&amp;gt;{% for allergy in content.allergy.all %}{{ allergy }} {% endfor %}&amp;lt;/td&amp;gt; .all属性を使用しforループで並べる。 結論 多対多のリレーションはアレルギー表示や動画等のタグ表示、エンジニアの担当言語やスキル</description>
    </item>
    
    <item>
      <title>DjangoでYou are Trying to add a non-nullable fieldと表示されたときの対策【makemigrations】</title>
      <link>https://noauto-nolife.com/post/django-non-nullable/</link>
      <pubDate>Wed, 18 Nov 2020 08:23:05 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-non-nullable/</guid>
      <description>Djangoのモデルにフィールドを追加して、さあマイグレーションしようとすると、こんな表示がされることがある。 これはなんなのか、対策も兼ねて解説する。 解説 要するに、既にレコードが存在する状態で、NULL禁止かつデフォルト値指定なしのフィールドを追加するとこうなる。 デフォルト指定していないので、既存のレコードにはNULL禁止であるにも関わらず、NULLが入ってしまう。そこで既存のレコードはどうするか</description>
    </item>
    
    <item>
      <title>DjangoでHelloWorld【HttpResponse及びレンダリング】</title>
      <link>https://noauto-nolife.com/post/startup-django-helloworld/</link>
      <pubDate>Mon, 16 Nov 2020 08:50:24 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-django-helloworld/</guid>
      <description>Djangoのハローワールドは、やり方が何通りもある。 普通のPythonであれば、 print(&amp;quot;HelloWorld&amp;quot;) ほぼこの一通りであるが、Djangoの場合は主にHttpResponseの他に、テンプレートをレンダリングして返す方法がある。 一般的な開発においてはテンプレートのレンダリングが主流である。しかし、Django初心者、フレームワーク未経験者には難度が高い。故に、本記事では難度の低いHttpResponseから解説する</description>
    </item>
    
    <item>
      <title>Django-allauthのログインページの装飾を装飾する【テンプレートの追加】</title>
      <link>https://noauto-nolife.com/post/django-allauth-loginpage/</link>
      <pubDate>Wed, 11 Nov 2020 17:59:11 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-allauth-loginpage/</guid>
      <description>django-allauthにより、比較的簡単に認証関係の機能を実装できる。だが、装飾まではサポートされていない。 このような殺風景なログイン画面が表示されてしまうのだ。これをそのままにして顧客に納品させるわけにはいかない。 本記事ではこのdjango-allauthのログインページを装飾させる方法を解説する。 Django-allauthのインストールとsettings.py、urls.pyの設定 まず</description>
    </item>
    
    <item>
      <title>Djangoでページネーションを実装する方法【django.core.paginator】【パラメータ両立】</title>
      <link>https://noauto-nolife.com/post/django-paginator/</link>
      <pubDate>Wed, 11 Nov 2020 17:57:49 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-paginator/</guid>
      <description>殆どのプロジェクトで実装必須になるページネーション。 Djangoではdjango.core.paginatorが用意されているので比較的簡単に実装できる。しかし、単にページネーションを実装しただけでは他のURLパラメーターが保持されないので、例えば検索とページネーションを両立させることはできない。 本記事では他のURLパラメーターを保持した状態でページネーションを実装する術を解説する。 流れ views</description>
    </item>
    
    <item>
      <title>Djangoでスペース区切りでOR検索、AND検索をする方法【django.db.models.Q】</title>
      <link>https://noauto-nolife.com/post/django-or-and-search/</link>
      <pubDate>Wed, 11 Nov 2020 17:56:10 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-or-and-search/</guid>
      <description>普通、検索エンジンで検索する時、こう検索するであろう。 Django UUIDFields 使い方 Djangoのモデルオブジェクトで検索しようとすると、こうなる。 Model.objects.filter(title__contains=&amp;quot;Django UUIDFields 使い方&amp;quot;) これでは検索結果が出てこない。検索時にスペースも文字列の1つとして考えるからだ(『Django UUIDFields 使い方』を含むタイトルを表示) そこで、スペース区切りのキーワード検索をするときは、Qクラスを使用する。 結論 結論から言うと、コード(views.py)はこ</description>
    </item>
    
    <item>
      <title>【Restful】DjangoでAjax(jQuery)を実装する方法【Django REST Framework使用】</title>
      <link>https://noauto-nolife.com/post/django-ajax-restful/</link>
      <pubDate>Tue, 10 Nov 2020 14:01:19 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax-restful/</guid>
      <description>先日の記事にて、DjangoでAjax(jQuery)を実装する方法を解説した。 ただ、RestfulAPIを使用すれば、さらに少ないコードでAjaxを実装することができる。 RestfulAPI、Django REST Frameworkとは RestfulAPIとは、HTTPリクエストに応じてサーバーの処理を切り分けることができるAPIのこと。 HTTPリクエストのヘッダ部には、リクエスト送信先のURLとリクエ</description>
    </item>
    
    <item>
      <title>Djangoで画像及びファイルをアップロードする方法</title>
      <link>https://noauto-nolife.com/post/django-fileupload/</link>
      <pubDate>Thu, 05 Nov 2020 15:30:14 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-fileupload/</guid>
      <description>Djangoで画像やファイルをアップロードする方法をまとめる。 流れ 必要なライブラリのインストール settings.pyとurls.pyの追記 models.pyでフィールドの定義 forms.pyでフォームを作る views.pyで受け取り処理 templatesにフォームを設置 マイグレーション 開発用サーバーの立ち上げ 必要なライブラリのインストール 今回はアップロード後のバリデーションを行うため、Pytho</description>
    </item>
    
    <item>
      <title>DjangoでDBに格納したデータをダンプ(バックアップ)させる【dumpdata】</title>
      <link>https://noauto-nolife.com/post/django-dumpdata/</link>
      <pubDate>Thu, 05 Nov 2020 14:38:34 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-dumpdata/</guid>
      <description>以前、Djangoで開発中に初期データを入力する方法をしたが、Djangoではその逆も可能。 つまり、DBに既に格納されているデータをダンプ(バックアップ)する事ができる。それがこれ python3 manage.py dumpdata [アプリ名] &amp;gt; [アプリ名]/fixture/data.json 実際にやってみるとこうなる。 json形式でダンプされ、そのままでは改行が施されていないので、}},の次に改行を設置する。vimなら下記正規表現を実行 s/}},/}},\r/g 整</description>
    </item>
    
    <item>
      <title>DjangoでAjax(jQuery)を実装する方法【非同期通信】【DRF不使用版】</title>
      <link>https://noauto-nolife.com/post/django-ajax/</link>
      <pubDate>Thu, 05 Nov 2020 12:05:15 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax/</guid>
      <description>ウェブアプリケーションでAjax(非同期通信)が使えるようになれば、ページ内の一部の要素のみを更新させることができる。 それすなわち、 通信量の大幅な削減 ページのちらつき低減 SPA(シングルページアプリケーション)の開発可能 ロングポーリングを使用した永続的な接続が可能(→オンラインチャットなどに転用可能) など、様々な恩恵が得られる。 Ajaxの実装は実質templatesとviews.pyの編集のみと非</description>
    </item>
    
    <item>
      <title>Djangoのマイグレーションのエラー時の対処法</title>
      <link>https://noauto-nolife.com/post/django-migrate-error/</link>
      <pubDate>Thu, 05 Nov 2020 08:46:39 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-migrate-error/</guid>
      <description>Djangoで開発を進めている時、マイグレーションのエラーにぶち当たるときがあるが、大抵はmigrationsディレクトリを編集していけばいいだけなので、それほど難しいものではない。 本記事ではmigrationsディレクトリ内のファイル編集を行うことで、マイグレーションのエラー時の対処法をまとめる。 サンプルコード まず、マイグレーションエラーの再現をするために、サンプルのコードを下記に公開した。プロ</description>
    </item>
    
    <item>
      <title>DjangoをDEBUG=FalseでHerokuにデプロイする方法</title>
      <link>https://noauto-nolife.com/post/django-deploy-heroku/</link>
      <pubDate>Mon, 26 Oct 2020 11:16:34 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-heroku/</guid>
      <description>プロジェクトのディレクトリ構造は、『現場で使えるDjangoの教科書 基礎編』に準拠している。 クラウドにインストールさせるライブラリの定義(requirements.txt) pycharm等の統合開発環境を使用していて、仮想環境が動いている場合(既にターミナルの左側に(venv)等の表示がされている場合)、下記コマンドを実行して、requirements.txtを生成する。 pip freeze &amp;gt; requirements.txt もし、仮想環境を使</description>
    </item>
    
    <item>
      <title>DjangoをLinux(Ubuntu)サーバーにデプロイする方法【Nginx&#43;PostgreSQL】</title>
      <link>https://noauto-nolife.com/post/django-deploy-linux/</link>
      <pubDate>Mon, 26 Oct 2020 11:16:29 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-linux/</guid>
      <description>DjangoをLinuxサーバーにデプロイできれば、クラウドとは違ってハードウェアの性能を余すこと無く使うことができる。 高度なAIを運用したり、それなりにセキュリティが求められるウェブアプリを運用する予定であれば実機のLinuxサーバーにデプロイしたほうが良い。 デプロイまでの流れ PostgreSQLとNginxのインストール settings.pyの修正 ホームディレクトリにプロジェクト一式を設置 必要</description>
    </item>
    
    <item>
      <title>Djangoで開発中、データベースへ初期データを入力する【loaddata】</title>
      <link>https://noauto-nolife.com/post/django-loaddata/</link>
      <pubDate>Sat, 24 Oct 2020 18:12:29 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-loaddata/</guid>
      <description>Djangoで開発中にテストしたい時、デプロイ後に初期データを突っ込んで即公開したい時、どうしてもデータの入力作業が出てくる。 Seleniumで入力作業を自動化する方法もあるが、わざわざそんなことをしなくても初期データを突っ込む方法がある。それが python3 manage.py loaddata fixture/data.json models.pyに基づいたjsonファイルを作る まず、bbs/models.pyが下記のような状態だとする。 from django.db import models class Topic(models.Model): class Meta: db_table = &amp;quot;topic&amp;quot; name = model</description>
    </item>
    
    <item>
      <title>Djangoで『このページを表示するにはフォームデータを..』と言われたときの対処法</title>
      <link>https://noauto-nolife.com/post/django-redirect/</link>
      <pubDate>Sat, 24 Oct 2020 17:22:29 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-redirect/</guid>
      <description>『このページを表示するにはフォームデータを再度送信する必要があります。フォームデータを再送信すると以前実行した検索、投稿や注文などの処理が繰り返されます。』 POST文を実行した直後に更新ボタンを押すと、こんなふうに表示される時。こういうときはリダイレクトすればOK。 views.pyを修正する redirectをimport。POST文のreturnにredirect関数を返せばいいだけ。 from django.shortcuts import redirect #P</description>
    </item>
    
    <item>
      <title>Djangoで数値のカンマ区切りを実装させる</title>
      <link>https://noauto-nolife.com/post/django-comma/</link>
      <pubDate>Sat, 24 Oct 2020 16:48:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-comma/</guid>
      <description>在庫とかお金とか扱うウェブアプリだとカンマ区切りは必須。 JSに任せてもいいけど、結局正規表現になる上にユーザーに負担を強いるのはどうかと。 ということでDjango側でカンマ区切りを簡単に実装させる。 settings.pyの追記 INSTALLED_APPSに以下を追加。 &#39;django.contrib.humanize&#39;, 下記をINSTALLED_APPSの上に追加。これで3桁区切りになる。 NUMBER_GROUPING = 3 3桁区切りで表示させたいテンプレートの追記 htmlの冒</description>
    </item>
    
    <item>
      <title>【メール認証】Django-allauthの実装方法とテンプレート編集【ID認証】</title>
      <link>https://noauto-nolife.com/post/startup-django-allauth/</link>
      <pubDate>Sat, 24 Oct 2020 16:32:35 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-django-allauth/</guid>
      <description>ここに、Django-allauthの実装方法をまとめる。主にsettings.pyを操作することになる。 また、allauth付属のテンプレートではHTMLのみなのでテンプレート及びCSSによる装飾も付せて説明する。 はじめに django-allauthは外部ライブラリなので、pipコマンドでインストールする必要がある。 pip install django-allauth ユーザーIDとパスワードを使用した認証方法の実装 ユーザーIDとパスワードを</description>
    </item>
    
    <item>
      <title>DjangoにPythonスクレイピングを実装した簡易検索エンジンの作り方【BeautifulSoup】</title>
      <link>https://noauto-nolife.com/post/django-scraping/</link>
      <pubDate>Sat, 24 Oct 2020 12:25:17 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-scraping/</guid>
      <description>DjangoにPythonスクレイピングを実装させるだけで簡易的な検索エンジンを作ることができる。 しかも、モデルの定義は不要でビューとテンプレートだけなので初心者の演習におすすめ。 流れ Djangoの環境構築、プロジェクトの作成等は割愛します。 アプリを作る urls.pyを修正 views.pyを作る テンプレートを作る スクレイピングのコードを作る views.pyを修正 テンプレートを修正 開発サーバーを起動</description>
    </item>
    
    <item>
      <title>【地理空間情報】GeoDjangoの実装方法【PostGIS&#43;PostgreSQL&#43;国土地理院データ】</title>
      <link>https://noauto-nolife.com/post/startup-geodjango/</link>
      <pubDate>Wed, 21 Oct 2020 16:46:02 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-geodjango/</guid>
      <description>圧倒的に日本語の情報、及びソースコードが不足しているgeodjangoについてまとめています。(勉強してすぐにまとめているので、多少間違いがあるかも。) Ubuntu 18.04 LTS にて動作確認済み。 流れ Djangoのインストール PostgreSQLのインストール GEOS、GDAL、PROJ4、PostGISのインストール プロジェクトの作成 アプリの作成 settings.pyの書き換え models.pyの書き換え 国土交通省</description>
    </item>
    
    <item>
      <title>Djangoビギナーが40分で掲示板アプリを作る方法</title>
      <link>https://noauto-nolife.com/post/startup-django/</link>
      <pubDate>Tue, 20 Oct 2020 14:20:34 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-django/</guid>
      <description>公式のDjangoチュートリアルではよくわからない方に捧げる 対象読者は既にDjangoをインストール済み、Linux系コマンド習得済み、Python及びHTML/CSS/JSの基本構文を把握済みとする。 流れ 以下、流れ。 プロジェクトを作る(5分) アプリを作る(5分) settings.pyの書き換え(5分) urls.pyでURLの指定(5分) views.pyで処理の定義(5分) templatesでHT</description>
    </item>
    
  </channel>
</rss>