<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>上級者向け on 自動化無しに生活無し</title>
    <link>https://noauto-nolife.com/tags/%E4%B8%8A%E7%B4%9A%E8%80%85%E5%90%91%E3%81%91/</link>
    <description>Recent content in 上級者向け on 自動化無しに生活無し</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 20 Aug 2022 17:55:28 +0900</lastBuildDate>
    
	<atom:link href="https://noauto-nolife.com/tags/%E4%B8%8A%E7%B4%9A%E8%80%85%E5%90%91%E3%81%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【Django】FontAwesomeで星のアイコンを使ったレビューの投稿と表示</title>
      <link>https://noauto-nolife.com/post/django-star-review/</link>
      <pubDate>Sat, 20 Aug 2022 17:55:28 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-star-review/</guid>
      <description>最終的にこのようになる。 今回はテンプレートのwithとcenterは不使用とした。 そして、5つ星の内、4つ星でレビューした場合、空の星を1つ描画する仕様に仕立てた。 参照 【Django】テンプレートで数値を使用したforループを実行する方法【レビューの星のアイコン表示などに有効】 HTML5とCSS3だけでAmazon風の星レビューのフォームを再現する【ホバーした時、ラジオボタンのチェックされた時に星</description>
    </item>
    
    <item>
      <title>【Django】モデルに計算可能な時間を記録する【勉強時間・筋トレ時間の記録系ウェブアプリの作成に】【DurationField】</title>
      <link>https://noauto-nolife.com/post/django-models-time-calc/</link>
      <pubDate>Sat, 13 Aug 2022 14:44:47 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-time-calc/</guid>
      <description>例えば、勉強時間や筋トレ時間を記録するウェブアプリを作るとする。 この時に、ネックになるのが、時間を記録するモデルフィールド。 IntegerFieldで記録するべきか、DatetimeFieldでtimedeltaを使うか。 いずれにせよ、合計や平均などを出さないといけないので、このフィールド選択を間違えると後々大変なことになる。 フォームの形式も考慮する必要がある。 そこで、本記事では、時間を記録する方</description>
    </item>
    
    <item>
      <title>【Django】Cookieをサーバーサイドで操作する</title>
      <link>https://noauto-nolife.com/post/django-control-cookie/</link>
      <pubDate>Fri, 12 Aug 2022 16:32:07 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-control-cookie/</guid>
      <description>カジュアルなウェブアプリではDBにデータを保存させるよりもCookieに直接保存する場合が多いだろう。 簡易掲示板における名前など、一度入力したデータを再度入力させる場合も、クライアントにとっては使い勝手が悪いので、Cookieをセットして表示させたほうが良い。 サンプルとなるコードはいつもの40分Django。 views.pyにてCookieをセット、参照する testというキー名、値はHelloでC</description>
    </item>
    
    <item>
      <title>【Django】カレンダーを更に改良する</title>
      <link>https://noauto-nolife.com/post/django-calendar-custom/</link>
      <pubDate>Mon, 08 Aug 2022 16:16:36 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-calendar-custom/</guid>
      <description>カレンダー機能に年月指定をするリンクとフォームを用意した。 ソースコード https://github.com/seiya0723/django_calendar_custom</description>
    </item>
    
    <item>
      <title>【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-allauth-bbs/</link>
      <pubDate>Sat, 30 Jul 2022 08:46:59 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-allauth-bbs/</guid>
      <description>手元のディレクトリ内で雛形が分散していたので、自分用に作った。 コードは40分Django簡易掲示板から。allauthはsettings.pyにID認証を、ユーザーモデルはDjangoのGitHubから何も書き加えていないモデルをそのまま流用した。 以前はfirst_nameとlast_nameを1つのhandle_nameにしたが、今回は元に戻した。 雛形をすぐにDLして書き換えができるようにGit</description>
    </item>
    
    <item>
      <title>【Django】アップロードするファイルサイズに上限をセットする【validators】</title>
      <link>https://noauto-nolife.com/post/django-fileupload-limit-size/</link>
      <pubDate>Fri, 13 May 2022 16:04:39 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-fileupload-limit-size/</guid>
      <description>本記事ではアップロードするファイルサイズに上限をセットする方法を解説する。 ただし、ビュー側にファイルサイズの上限をチェックする機能を実装させるのではなく、以前紹介した、『【Django】models.pyにて、オリジナルのバリデーション処理を追加する【validators】【正規表現が通用しない場合等に有効】』を元に実装させる。 ビューに判定機能を実装させる方法でも問題はないが、投稿するビューが二分</description>
    </item>
    
    <item>
      <title>WebSocketとポーリング、ロングポーリングの違い【非同期通信と双方向通信】</title>
      <link>https://noauto-nolife.com/post/polling-long-polling-websocket-difference/</link>
      <pubDate>Thu, 05 May 2022 08:53:28 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/polling-long-polling-websocket-difference/</guid>
      <description>前説 非同期通信 非同期通信とは、2人以上のユーザーがそれぞれ自分たちの都合のいいタイミングでデータを受信し、通信をすることである。 同期通信とは、リクエストを送信した後、レスポンスを受け取るまで何もできない。 非同期通信ではリクエスト送信をJavaScriptに任せることで、リクエスト送信後からレスポンスを受け取るまでに、続けて処理を行うことができる。 この非同期通信を行うために使用する技術がAjaxであ</description>
    </item>
    
    <item>
      <title>【Django】カスタムユーザーモデルに記録した自分のユーザー情報を編集する【ユーザー情報変更画面に】</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-mydata-edit/</link>
      <pubDate>Tue, 03 May 2022 17:23:44 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-mydata-edit/</guid>
      <description>Djangoでは新規会員登録したとき、記録できるのはユーザーIDとパスワードだけで、会員登録フォームの追加をしない限り、姓名の記録はできない。 仮に新規会員登録した時にフォームが与えられていたとしても、後にその編集をするページがなければ仕方ない。(例えば、姓名が変わった時に変更する手続きをするフォームページを用意していないと、後々問題になる) そこで、本記事ではユーザー情報を編集するページを作る方法を</description>
    </item>
    
    <item>
      <title>【Django】channelsを使ってWebSocketを実現させる【チャットサイト開発に】</title>
      <link>https://noauto-nolife.com/post/startup-django-channels-web-socket/</link>
      <pubDate>Mon, 02 May 2022 21:34:55 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-django-channels-web-socket/</guid>
      <description>django-channelsのチュートリアルに倣って、WebSocketを使ったチャットサイトを作った。 とても実装難易度が高く、一筋縄では行かない。そのため実装手順の備忘録として本記事をまとめておく。 わかっていること WebSocketとはプロトコルのこと、HTTPでは実現できない双方向通信を実現させるためのもの 前もってHTTPでWebSocketの通信経路を作る必要がある WebSocketの経路</description>
    </item>
    
    <item>
      <title>【Django】Ajax(jQuery)でロングポーリングを実装させる【チャットサイトの開発に】</title>
      <link>https://noauto-nolife.com/post/django-ajax-long-polling/</link>
      <pubDate>Thu, 28 Apr 2022 16:06:12 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax-long-polling/</guid>
      <description>Ajaxを使えば、ページを部分的に更新させることができる。 そして、setTimeoutを使うことで、指定した時間おきにページを部分的に更新することができる。 ただ、Ajaxによるリクエストとレスポンスを繰り返している(ただのポーリング)ようでは、ウェブサーバーに負担が掛かってしまう。 クラウドサーバーなどは死活問題で、負荷が増えると課金してサーバーの強化などを考慮しなければならない。 そこで、リクエスト</description>
    </item>
    
    <item>
      <title>【Django】スペース区切りでOR・AND検索を改定する</title>
      <link>https://noauto-nolife.com/post/django-or-and-search-revision/</link>
      <pubDate>Fri, 15 Apr 2022 16:42:39 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-or-and-search-revision/</guid>
      <description>以前、紹介した『Djangoでスペース区切りでOR検索、AND検索をする方法【django.db.models.Q】』では少々ビューの見通しが悪い。 また、他の絞り込みなどの機能も考慮した場合、キーワードが無かった場合にリダイレクトをするのはおかしい。 そこで本記事では検索処理の改定を行う。 views.py from django.shortcuts import render,redirect from django.views import View from .models import Topic from .forms import TopicForm from django.db.models import Q class IndexView(View): def get(self, request, *args, **kwargs): context = {} query = Q() if &amp;quot;search&amp;quot; in request.GET: search = request.GET[&amp;quot;search&amp;quot;] raw_words = search.replace(&amp;quot; &amp;quot;,&amp;quot; &amp;quot;).split(&amp;quot; &amp;quot;) words = [ w for w in raw_words if</description>
    </item>
    
    <item>
      <title>【Django】models.pyにて、オリジナルのバリデーション処理を追加する【validators】【正規表現が通用しない場合等に有効】</title>
      <link>https://noauto-nolife.com/post/django-models-origin-validators/</link>
      <pubDate>Fri, 15 Apr 2022 14:33:20 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-origin-validators/</guid>
      <description>例えば、簡易掲示板にて、特定の禁止ワードを含んだ投稿を拒否したい場合。 承認制にして、管理者が文面を確認した上で公開を許す方法もあるが、それでは人件費がかかる。 なるべく保存する前に禁止ワードを含んでいるかどうかをチェックする仕組みにしたい。 そういう時は、validatorsに独自の関数を割り当てれば良い。 コードは40分Djangoから流用して作る models.py 不快語を除外するバリデーションを実装させる。 from django.db import models</description>
    </item>
    
    <item>
      <title>【Django】Ajaxで複数枚の画像を一回のリクエストでアップロードする。</title>
      <link>https://noauto-nolife.com/post/django-ajax-multi-img-upload/</link>
      <pubDate>Mon, 21 Mar 2022 18:25:17 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax-multi-img-upload/</guid>
      <description>経緯 例えば、1つのデータに対して、複数枚の画像を記録したい場合がある。 ECサイトの商品がその例で、1つの商品に対して、複数枚の画像を記録する必要がある。 しかも、商品に対して記録する画像の枚数が10枚以上になる可能性もあり、これを1つのモデルに画像フィールド10個などとしているようではDBの構造上の問題に発展する。 だからこのような場合は、商品モデルと商品画像モデルの1対多のリレーションを組むべきであ</description>
    </item>
    
    <item>
      <title>DjangoRestFrameworkは本当に必要なのか？【Restful化とAjaxでデータを送信するときの問題】</title>
      <link>https://noauto-nolife.com/post/django-rest-framework-need-ajax/</link>
      <pubDate>Sat, 26 Feb 2022 08:40:27 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-rest-framework-need-ajax/</guid>
      <description>結論 DjangoはデフォルトでRestfulに対応している(Ajaxを使ってPUT,DELETE,PATCHメソッドの送信ができる)。 ただし、PUT,DELETE,PATCHのリクエストボディを参照するのはやや複雑。 そのため、それらのメソッドを使ってリクエストを送信する場合、DRFを使ったほうが良い。 素のDjangoはRestfulに対応している AjaxでPUT,DELETE,PATCHメソッドを</description>
    </item>
    
    <item>
      <title>Djangoで現在時刻以降の日時入力を促すのであれば、MinValueValidatorを使用する【DateTimeField】</title>
      <link>https://noauto-nolife.com/post/django-thereafter-timezone-now/</link>
      <pubDate>Mon, 07 Feb 2022 07:28:47 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-thereafter-timezone-now/</guid>
      <description>予約システムなどでは、指定した日時以降の日時を入れてもらう必要がある。 入力できる日時にフロント側で制限をかけることができれば良いが、それだけでは限界がある。 そこで、Djangoではmodelsのフィールドオプションであるvalidatorsを使用することで、指定した日時以降の日時だけを入力できるようになる。 MinValueValidatorsで現在時刻以降の日時入力をさせる モデルはこうかけばよい。</description>
    </item>
    
    <item>
      <title>【Stripe】Djangoにクレジットカード決済機能を実装させる</title>
      <link>https://noauto-nolife.com/post/startup-django-stripe/</link>
      <pubDate>Thu, 03 Feb 2022 08:08:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-django-stripe/</guid>
      <description>DjangoでECサイトや課金ゲームサイト等を展開しようと考えているのであれば、避けて通ることができないのがカード決済。 Stripeというカード決済代行会社を利用することで、決済処理を手軽に実装させることができる。 本記事ではその一例を紹介する。 共通設定 まず、stripeライブラリをインストールする pip install stripe settings.pyにて下記をセットしておく。Stripeの秘密鍵は.gitignoreに指定</description>
    </item>
    
    <item>
      <title>Djangoでpython3のsubprocessモジュールを使い、任意のコマンドをなるべく安全に配慮して実行させる</title>
      <link>https://noauto-nolife.com/post/django-secure-subprocess/</link>
      <pubDate>Tue, 04 Jan 2022 10:16:48 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-secure-subprocess/</guid>
      <description>ふと思った。 毎度毎度、SSHクライアントがインストールされている端末を起動させ、サーバーにログイン、コマンドで操作するめんどくささ、どうにかできないだろうかと。 ウェブアプリから任意のコマンドを実行することができれば、わざわざSSHを使わなくても、ブラウザだけで簡単にコマンドが実行できる。ただ、問題になってくるのがセキュリティ。 不適切なコマンドを実行されてしまうと、当然システムは壊れる。そこで、なる</description>
    </item>
    
    <item>
      <title>【Django】allauth未使用でユーザー認証機能を実装した簡易掲示板【ログインとログアウトのみ】</title>
      <link>https://noauto-nolife.com/post/django-auth-not-allauth/</link>
      <pubDate>Sat, 01 Jan 2022 07:00:48 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-auth-not-allauth/</guid>
      <description>Djangoでは、サードパーティー製ライブラリとしてdjango-allauthを使用することで、誰でも簡単にユーザー認証機能を実装させることができる。 とはいえ、事情によってライブラリの使用が制限されていたり、単なるユーザーIDとパスワードによるログインを行いたいだけであれば、デフォルトのLoginView及び、LogoutViewを使えば簡単に実装できる。 本記事ではallauthよりも手っ取り早</description>
    </item>
    
    <item>
      <title>【Django】年月検索と、年別、月別アーカイブを表示させる【最新と最古のデータから年月リストを作成(Trunc不使用)】</title>
      <link>https://noauto-nolife.com/post/django-year-month-search-and-list/</link>
      <pubDate>Sat, 25 Dec 2021 20:57:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-year-month-search-and-list/</guid>
      <description>Djangoで月別アーカイブと年月計算を実装させる 元となったコードは40分Djangoにモデルへ投稿日を記録するフィールド(dt)を追加している。 forms.py from django import forms from django.core.validators import MinValueValidator,MaxValueValidator from .models import Topic class TopicForm(forms.ModelForm): class Meta: model = Topic fields = [&amp;quot;comment&amp;quot;] #モデルを使用しないフォームクラス class YearMonthForm(forms.Form): year = forms.IntegerField() month = forms.IntegerField(validators=[MinValueValidator(1),MaxValueValidator(12)]) モデルを使用しないフォームクラスで年と月を数値型で受け取る。月は1から12までの数値なので、validatorsで追加の制約を付与する。 views.py 年月別アーカイブのリ</description>
    </item>
    
    <item>
      <title>【Django】テンプレートで数値を使用したforループを実行する方法【レビューの星のアイコン表示などに有効】</title>
      <link>https://noauto-nolife.com/post/django-template-integer-for-loop/</link>
      <pubDate>Tue, 21 Dec 2021 16:28:13 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-template-integer-for-loop/</guid>
      <description>通常、DjangoTemplateLanguageのforループは数値型のループは許さない。ループが許されているのは、文字列型かリスト型、イテラブルなオブジェクトに限定される。 これを普通のPythonで表現するのであれば、こんな状態。 for content in contents: print(content) このcontentsに数値を入れることはできないのはPythonをやっていればわかる。しかし、とある方法を使えば数値のループは実現できる。 テンプレートタグw</description>
    </item>
    
    <item>
      <title>【DRF】Django Rest Frameworkでリスト型のバリデーションも行う【UUIDや文字列を格納したリスト型のバリデーションに】</title>
      <link>https://noauto-nolife.com/post/django-rest-framework-listfield/</link>
      <pubDate>Tue, 14 Dec 2021 15:04:59 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-rest-framework-listfield/</guid>
      <description>例えば、Ajaxを使用して複数選択削除を行いたい場合、idもしくはuuidのリスト型をサーバーサイドに送信することになるだろう。 そういう時、DjangoRESTFramework(以下DRF)のシリアライザを使用すると良いだろう。 UUIDを含むリスト型をバリデーションする #複数選択削除で利用 class UUIDListSerializer(serializers.Serializer): id_list = serializers.ListField( child=serializers.UUIDField() ) これで実現できる。 DjangoのFormクラスで実現させる場合。 リスト型で送られてくるデータの</description>
    </item>
    
    <item>
      <title>【Django】Modelクラス、Formクラス、もしくはSerializerクラスのsaveメソッドで保存した後、保存したモデルオブジェクトのIDを手に入れる方法【データ保存した後、関連するデータも追加したい場合】</title>
      <link>https://noauto-nolife.com/post/django-forms-save-model-object-id/</link>
      <pubDate>Sat, 11 Dec 2021 07:30:48 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-forms-save-model-object-id/</guid>
      <description>例えば、グループとそれに所属するメンバーのデータを一気に新規作成するタイプのフォームを作った場合。 グループとメンバーは1対多の関係になっており、それぞれの新規作成を1回のリクエストで済ませる場合は、まずグループを新規作成、その後そのグループに紐付いたメンバーを新規作成する必要がある。 ここで問題になるのが、メンバーのフィールドの一部にグループのIDを記録しなければならないこと。こういう時、保存したグ</description>
    </item>
    
    <item>
      <title>【Django】requestオブジェクトからクライアントのUAやIPアドレス、CSRFCookieなどをチェック、テンプレート上に表示する。</title>
      <link>https://noauto-nolife.com/post/django-request-meta/</link>
      <pubDate>Sat, 11 Dec 2021 07:26:40 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-request-meta/</guid>
      <description>すぐ忘れるので備忘録として。 テンプレートにユーザーのIPアドレス等を表示させたい場合、下記DTLを任意のテンプレートに書き込む。 {{ request.META }} これでリクエストに関連するデータが全て表示される。必要なデータを選び、例えばREMOTE_ADDRであれば {{ request.META.REMOTE_ADDR }} とすれば良い。</description>
    </item>
    
    <item>
      <title>DjangoでAjax(jQuery)を実装、送信と同時に投稿内容を確認する【Django Rest Framework不使用版】</title>
      <link>https://noauto-nolife.com/post/django-ajax/</link>
      <pubDate>Sat, 13 Nov 2021 07:05:15 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax/</guid>
      <description>ウェブアプリケーションでAjaxが使えるようになれば、ページ内の一部の要素のみを更新させることができる。 それすなわち、 通信量の大幅な削減 ページのちらつき低減 SPA(シングルページアプリケーション)の開発可能 ロングポーリングを使用した永続的な接続が可能(→オンラインチャットなどに転用可能) など、様々な恩恵が得られる。 Ajaxの実装は実質テンプレートとビュー、静的ファイルの編集のみと非常にシンプル。 今</description>
    </item>
    
    <item>
      <title>【Django】canvasで描画した画像をAjax(jQuery)で送信【お絵かきBBS、イラストチャット、ゲームのスクショ共有などに】</title>
      <link>https://noauto-nolife.com/post/django-canvas-send-img-by-ajax/</link>
      <pubDate>Thu, 21 Oct 2021 07:25:39 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-canvas-send-img-by-ajax/</guid>
      <description>例えば、チャットサイト、掲示板サイトでユーザーが描画したイラストを投稿できる形式にしたい時。 ユーザーが手元の端末でペイントツールを起動して画像を保存して、サイトに添付して貼り付けるのはやや面倒。それだけでなく、サイト独自のレギュレーション(お題に沿ってイラストを付け加える形式、指定された色しか使ってはいけないなど)がある場合、ユーザーのペイントツールでそれを強いるのは不可能に近い。 そこで、サイト上</description>
    </item>
    
    <item>
      <title>Djangoで任意のHTTPレスポンス(ForbiddenやNotFoundなど)を返却する【HttpResponse subclasses】</title>
      <link>https://noauto-nolife.com/post/django-http-response/</link>
      <pubDate>Sat, 02 Oct 2021 18:56:03 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-http-response/</guid>
      <description>あまり需要が無いかも知れないが、状況によっては手動でHTTPResponseを指定して返却したい場合もあるだろう。 本記事ではよく使用すると思われるレスポンスをまとめる。 HttpResponseBadRequest from django.http import HttpResponseBadRequest from django.views import View class BbsView(View): def get(self, request, *args, **kwargs): return HttpResponseBadRequest(&amp;quot;bad&amp;quot;) index = BbsView.as_view() リクエストの一部が欠落している場合など、クライアント側のエラーに表示させる。 HttpResponseNotFound from django.http import HttpResponseNotFound from django.views import View class BbsView(View): def get(self, request, *args, **kwargs): return HttpResponseNotFound(&amp;quot;not found&amp;quot;) index = BbsView.as_view() 引数内に入れた内容をクライアントのブラウザにHTMLとして表示させる コ</description>
    </item>
    
    <item>
      <title>【jQuery】ボタン式の横スライダーを自作する【通販サイト・コンテンツ共有サイトなどに】</title>
      <link>https://noauto-nolife.com/post/javascript-carousel-origin-slider/</link>
      <pubDate>Sun, 26 Sep 2021 03:09:45 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/javascript-carousel-origin-slider/</guid>
      <description>通販サイトなどでよくある。横スクロール型のスライダーを作る。slick.jsなどを使えば簡単に実現できるが、かえって複雑なので、自作した。 ソースコード HTML。jQueryを読み込み、別途JavaScriptとCSSを読み込む。 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Hello World test!!&amp;lt;/title&amp;gt; &amp;lt;!--jquery読み込み--&amp;gt; &amp;lt;script src=&amp;quot;https://code.jquery.com/jquery-3.4.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;script.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style.css&amp;quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;preview_control_area&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;data_preview_area&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;data_preview_frame&amp;quot;&amp;gt;&amp;lt;div class=&amp;quot;data_preview_content&amp;qu</description>
    </item>
    
    <item>
      <title>【Django&#43;AWS】独自ドメインを割り当てHTTPS通信を実現した状態で、EC2(Ubuntu&#43;Nginx)へデプロイする</title>
      <link>https://noauto-nolife.com/post/django-deploy-ec2-origin-domain/</link>
      <pubDate>Mon, 13 Sep 2021 08:19:27 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-ec2-origin-domain/</guid>
      <description>既に、【AWS】EC2にムームドメインで取得した独自ドメインを割り当て、HTTPS通信を行う【Route 53 + Certificate Manager + ロードバランサ(ELB)】の内容を終え、独自ドメインでHTTPS通信が可能な状態である前提で解説する。 一部、DjangoをAWSのEC2(Ubuntu)にデプロイすると内容が重複しているが、AWS側の設定は一切行わない。書き換えが必要なのは、settings.pyのALLOWED_HO</description>
    </item>
    
    <item>
      <title>【Django】SQLiteでも特定フィールドに対してのdistinctっぽい事(重複除去)を行う【通常はPostgreSQLのみ有効】</title>
      <link>https://noauto-nolife.com/post/django-distinct-on-sqlite/</link>
      <pubDate>Fri, 10 Sep 2021 11:21:51 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-distinct-on-sqlite/</guid>
      <description>以下のクエリはPostgreSQLのみ有効。 Topic.objects.all().distinct(&amp;quot;comment&amp;quot;) このように.disitinct()に引数としてフィールド名を指定できるのは、PostgreSQLだけ。.values()を使う方法もあるが、モデルオブジェクトでなくなる時点で汎用性に乏しい。 そこで、重複するフィールドを除外したいのであれば、こうする。 topics = Topic.objects.all().order_by(&amp;quot;-dt&amp;quot;) d_list = [] n_list = [] for t in topics: if t.comment in d_list: continue d_list.append(t.comment) n_list.append(t) context[&amp;quot;topics&amp;quot;] = n_list これで重複するコメントを除外して新しいモデルオブジェクトの</description>
    </item>
    
    <item>
      <title>【Django】カスタムテンプレートタグ(フィルタ)でリンク付きのハッシュタグを実現する。【#から始まる正規表現】</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags-hashtags/</link>
      <pubDate>Sun, 05 Sep 2021 17:30:49 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags-hashtags/</guid>
      <description>Djangoのカスタムテンプレートタグ(フィルタ)を使うことでTwitterやyoutube等のハッシュタグを実現できる。 だが、ちょっとでも間違えると、簡単にXSS脆弱性を生み出してしまう可能性があるため、十分注意して実装する。 方法論 まず、普通のDTLはXSS対策のため、&amp;lt;や&amp;gt;等の特殊記号をエスケープしている。ハッシュタグを実現させるのであれば、まずはこれを除外する。そのため、mark</description>
    </item>
    
    <item>
      <title>【Django】kwargsを使ってビューを使いまわす【urls.py&#43;views.py】</title>
      <link>https://noauto-nolife.com/post/django-args-kwargs-view-recycle/</link>
      <pubDate>Thu, 02 Sep 2021 19:20:58 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-args-kwargs-view-recycle/</guid>
      <description>kwargsを使うことで似たような処理のビューを使いまわしできる。これによりビューのコード行数を大幅に削減可能。 状況 例えば、私のブログのように、記事一覧や記事本文を表示する左側のメインエリア、カテゴリやタグなどを表示するサイドエリア、2つのエリアがあったとする。 つまり、カテゴリやタグなどの情報は常に表示し、URLによってメインエリアの情報を切り替えたい場合、urls.pyはどうなるだろうか？ すぐに</description>
    </item>
    
    <item>
      <title>【Django】Windowを使ってレコードの累計値を計算して出力【売上の累計表示、小計(累積)表示などに有効】</title>
      <link>https://noauto-nolife.com/post/django-models-window/</link>
      <pubDate>Wed, 01 Sep 2021 18:23:58 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-window/</guid>
      <description>日付でソートして売上を表示するとして、その日付になるまでの累計(累積)売上金額を表示したいとする。 そういう時はWindowを使えば、累計(累積)値を表示させることができる。 ソースコード 前回の月ごとに売上を表示するコードから流用。ビューとテンプレートの処理だけ書き換える。 from django.db.models import Sum,Window,F menus = Menu.objects.annotate(accumulate=Window(Sum(&amp;quot;amount&amp;quot;), order_by=[ F(&amp;quot;date&amp;quot;).desc(),F(&amp;quot;id&amp;quot;).asc() ] ) ).values(&amp;quot;id&amp;quot;,&amp;quot;name&amp;quot;,&amp;quot;date&amp;quot;,&amp;quot;amount&amp;quot;,&amp;quot;accumulate&amp;quot;).order_by(&amp;quot;-date&amp;quot;,&amp;quot;id&amp;quot;) 累積計算時(Windowの中)のorder_byとvaluesを実行した後のorder_byは揃えなければ</description>
    </item>
    
    <item>
      <title>【Django】MIDDLEWAREを作って、常にデータを表示する【requestにモデルオブジェクトを属性として追加する】</title>
      <link>https://noauto-nolife.com/post/django-create-middleware-add-request-attribute/</link>
      <pubDate>Sun, 29 Aug 2021 20:56:46 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-create-middleware-add-request-attribute/</guid>
      <description>例えば、サイトのどのページにアクセスしても表示させたいデータがあるとしよう。サイトのトップバーあたりにサイトの更新履歴(ニュース)のようなものをスライドして表示させたい時などがそうだ。サイトのニュースだから当然、誰でも見れる仕組みにする。 こういうどのページでも常時表示しなければならないデータがある時、いかにして手を打つか。当然、更新履歴は管理サイトから追加していくものだから、モデルを参照しなければ</description>
    </item>
    
    <item>
      <title>【Django】MIDDLEWAREを自作、未ログインユーザーにメディアファイルへのアクセスを拒否する【settings.py】</title>
      <link>https://noauto-nolife.com/post/django-create-middleware/</link>
      <pubDate>Sat, 28 Aug 2021 17:17:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-create-middleware/</guid>
      <description>未ログインユーザーに対して動画や画像等のメディアファイルは公開したくない。しかし、何も対策をしていないとメディアファイルは誰でも見放題の状態になってしまう。 たとえそれが有料コンテンツであったとしても、mp4やpngのリンクを直接アクセスするだけで誰でも見れる。これではユーザーは離反する。 そこで、どんなリクエストでも必ず通るDjangoのMIDDLEWAREを利用する。本記事ではMIDDLEWARE</description>
    </item>
    
    <item>
      <title>【Django】同一人物による工作(再生数の水増しなど)をいかにして防ぐか、方法と対策【unique_together,Recaptcha,UA,IPアドレス等】</title>
      <link>https://noauto-nolife.com/post/django-same-user-operate-prevent/</link>
      <pubDate>Thu, 26 Aug 2021 12:24:05 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-same-user-operate-prevent/</guid>
      <description>例えば、動画サイトを運営していて、動画の再生回数を記録する機能を実装したとする。 動画の検索で、再生数の多い順に並び替えて表示する機能が既にある場合、再生回数の水増しによって、全く面白くない動画が検索の上位に表示されるなどの問題が発生する。 それだけでなく、再生回数の水増しを放置してしまうと、ランキングも荒れ果て、結果的にユーザーが離反してしまう恐れもある。(※ただし、ランキングの集計方法によってある</description>
    </item>
    
    <item>
      <title>Djangoで中間テーブルありの多対多フィールドを使用したモデルに良いね・悪いねする【related_nameとカスタムユーザーモデル】</title>
      <link>https://noauto-nolife.com/post/django-m2m-through-good-bad/</link>
      <pubDate>Tue, 24 Aug 2021 13:03:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-through-good-bad/</guid>
      <description>状況 以前作った、【Django】Reverse accessor for &amp;lsquo;Topic.good&amp;rsquo; clashes with reverse accessor for &amp;lsquo;Topic.user&amp;rsquo;.というエラーの対処【Topicに対する良いね、多対多中間フィールドあり】では、モデルはできあがっているものの、肝心のトピックに良いね悪いねするビューの処理、テンプレートの描画までは解説していない。 そこで、今回はトピックに良いね悪いねをする方法を解説する。 bbs/models.pyとuse</description>
    </item>
    
    <item>
      <title>【Django】Reverse accessor for &#39;Topic.good&#39; clashes with reverse accessor for &#39;Topic.user&#39;.というエラーの対処【Topicに対する良いね、多対多中間フィールドあり】</title>
      <link>https://noauto-nolife.com/post/django-m2m-through-reverse-accessor-error/</link>
      <pubDate>Thu, 19 Aug 2021 10:41:05 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-through-reverse-accessor-error/</guid>
      <description>このエラーが発生する状況がやや複雑なので、状況から解説。 このエラーが起こる状況 まず、カスタムユーザーモデルを実装している。 モデルの中身は【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】から丸ごと流用。 そして、アプリのモデル。簡易掲示板に良いねと悪いね機能を実装している。 多対多の中間テーブルを手動で定義している。詳細は【django</description>
    </item>
    
    <item>
      <title>Djangoのモデルに独自メソッドを追加、テンプレートに表示【フィールド間の計算、他モデルの値の表示などに有効】</title>
      <link>https://noauto-nolife.com/post/django-models-add-method-template-attribute/</link>
      <pubDate>Sat, 07 Aug 2021 16:28:40 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-add-method-template-attribute/</guid>
      <description>モデルにメソッドを追加することで、テンプレート側から属性値として参照することができる。 from django.db import models class Topic(models.Model): comment = models.CharField(verbose_name=&amp;quot;コメント&amp;quot;,max_length=2000) time = models.IntegerField(verbose_name=&amp;quot;活動時間(分)&amp;quot;,default=0) level = models.IntegerField</description>
    </item>
    
    <item>
      <title>DjangoでDBへデータ格納時(save)、削除時(delete)に処理を追加する【models.py、forms.py、serializer.pyのメソッドオーバーライド】</title>
      <link>https://noauto-nolife.com/post/django-models-save-delete-override/</link>
      <pubDate>Sat, 07 Aug 2021 16:20:24 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-save-delete-override/</guid>
      <description>例えば、クライアントがお問い合わせフォームに入力して送信した時、DBに内容を保存すると同時に管理者に内容をメールで送信したい。そんなことは無いだろうか？ しかも、その保存のビューの処理が各所に分散していて、一つ一つ書いていくのが面倒な時。こういう時はモデルクラスのsaveメソッドを書き換える(オーバーライドする)ことで対処できる。 オーバーライドの方法 公式からコードを拝借。 models.pyにて、下記</description>
    </item>
    
    <item>
      <title>Djangoで数値型もしくはUUID型等のフィールドに、クライアント側から未入力を許可するにはnull=Trueとblank=Trueのオプションを</title>
      <link>https://noauto-nolife.com/post/django-models-uuid-int-null/</link>
      <pubDate>Sat, 07 Aug 2021 10:53:38 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-uuid-int-null/</guid>
      <description>タイトルの通り。 基本的な話として、blankとは空文字列のこと。だから文字列型扱いになる。一方でnullはPythonで言うとNoneであり、型は無い。 よってblank=Trueのフィールドオプションが許されるのは、CharField等の文字列型系のフィールドのみで、IntegerFieldやUUIDFieldには許されない。 と思われがちだが、それは半分誤解である。実は下記の指定は正しい。 dt = mo</description>
    </item>
    
    <item>
      <title>Djangoで複数の外部キーに対応したフィールドの個数をカウントする【annotate(Count)&#43;DISTINCT】</title>
      <link>https://noauto-nolife.com/post/django-foreign-count-distinct/</link>
      <pubDate>Sat, 31 Jul 2021 16:30:47 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-foreign-count-distinct/</guid>
      <description>【Django】外部キーに対応したデータの個数をカウントして表示【リプライ・コメント数の表示に有効】【annotate+Count】から annotateで外部キーで繋がっているコメント数をカウントしてフィールドを追加するには下記のようにすれば良い。 from django.db.models import Count Video.objects.annotate( num_comments=Count(&amp;quot;videocomment&amp;quot;) ).all().order_by(&amp;quot;-dt&amp;quot;) Countの第一引数に外部キーで繋がっているモデルクラスの小文字を文字列型で指定する。 しかし、マイリスト数、良いねの数など複数の外部キーで</description>
    </item>
    
    <item>
      <title>Djangoの管理サイト(admin)のフォームをforms.pyを使用してカスタムする【文字列入力フォームをtextareaタグで表現】</title>
      <link>https://noauto-nolife.com/post/django-admin-custom-form/</link>
      <pubDate>Sat, 31 Jul 2021 15:57:27 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-custom-form/</guid>
      <description>管理サイトのフォームはとりわけ何もしなければ、registerするモデルフィールドに依存する。 つまり、CharFieldの場合、inputタグtype=&amp;quot;text&amp;quot;が自動的に管理画面のフォームに挿入される。 そのため、何もしなければフィールドオプションがmax_length=2000でも1行のテキストボックスでしか入力できない。 改行もできなければ全体を確認することも困難な管理画面</description>
    </item>
    
    <item>
      <title>DjangoをAWSのEC2(Ubuntu)にデプロイする</title>
      <link>https://noauto-nolife.com/post/django-deploy-ec2/</link>
      <pubDate>Sun, 18 Jul 2021 09:45:32 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-deploy-ec2/</guid>
      <description>Herokuとは違ってサーバーが日本にもあり、なおかつ課金すれば大型のウェブアプリでもインターネット上に公開できる、それがAWS。 本記事ではAWSのEC2を使用し、デプロイ工程を解説する。 必要な知識 手順通りこなせばデプロイはできるが、作業の意味を理解するには、以下の知識を要する。 ネットワーク、データベース、セキュリティの知識 Linuxのコマンド(cp,mkdir,mv,cdなど) vimやnanoな</description>
    </item>
    
    <item>
      <title>【Django】カスタムユーザーモデルでユーザーブロック機能を実装させる【ManyToManyFieldでユーザーモデル自身を指定】</title>
      <link>https://noauto-nolife.com/post/django-m2m-usermodel/</link>
      <pubDate>Mon, 21 Jun 2021 21:36:59 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-usermodel/</guid>
      <description>本格的にSNS等のサービスを運用する時、必要になるのがユーザーフォロー(友達)やユーザーブロックの機能。理論上、いずれもユーザーとユーザーを多対多でつなぐことで実現できる。 今回はユーザーブロックの機能をカスタムユーザーモデルを使って再現する。 コードは【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】から流用している。 ユーザーモデル u</description>
    </item>
    
    <item>
      <title>【Django】views.pyの事前処理 VS (埋め込み型)カスタムテンプレートタグ・フィルタ</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags-vs-before-view-calc/</link>
      <pubDate>Tue, 15 Jun 2021 03:08:14 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags-vs-before-view-calc/</guid>
      <description>思考停止状態でカスタムテンプレートタグを作っているとき、ふと気づいた。 『これ、views.pyで事前に処理をしたほうが良いのではないか』と。 考察に至った背景 カスタムテンプレートタグは基本的にviews.pyがレンダリングをする段階で動作する。 つまりそれは、クライアントにレスポンスが届く直前であり、サーバーサイドが介入できる最後の処理である。 故に、『カスタムテンプレートタグを実行した後に、任意の処理</description>
    </item>
    
    <item>
      <title>【Django】admin.pyからカスタムアクションを追加し、管理サイトから実行【crontab、BaseCommandが使えない場合の対処法】</title>
      <link>https://noauto-nolife.com/post/django-admin-custom-action/</link>
      <pubDate>Mon, 14 Jun 2021 17:33:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-custom-action/</guid>
      <description>【Django】manage.pyコマンドを追加させる【バッチ処理、常駐プログラムなどに】から、manage.pyのコマンドを追加することができる。 だが、誰もがmanage.pyのコマンドを実行できるとも限らない。crontabが使えない場合もある。 特にコマンドを打ったことのない人向けにシステムの管理を行ってもらう場合、GUIで操作できる管理サイトからアクションを追加する方法が妥当と言えよう。 そこ</description>
    </item>
    
    <item>
      <title>Djangoの管理サイト(admin)をカスタムする【全件表示、全フィールド表示、並び替え、画像表示、検索など】</title>
      <link>https://noauto-nolife.com/post/django-admin-custom/</link>
      <pubDate>Thu, 10 Jun 2021 12:30:46 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-admin-custom/</guid>
      <description>admin.pyはとても便利ではあるが、ただのadmin.site.register([モデルクラス])ではとても使いづらい。 特にそのままでは管理サイト内で画像を取り扱ったり、複数のデータを参照したり、検索や絞り込みしたりすることはできない。 そこで、管理サイトをカスタマイズして使いやすくさせる。 コード 元コードは、Djangoで画像及びファイルをアップロードする方法から流用した。以下のようにmode</description>
    </item>
    
    <item>
      <title>【Django】allauthのurls.pyをカスタムする【新規アカウント作成、パスワード変更処理の無効化など】</title>
      <link>https://noauto-nolife.com/post/django-allauth-custom-urls/</link>
      <pubDate>Tue, 25 May 2021 09:49:51 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-allauth-custom-urls/</guid>
      <description>Django-allauth。とても便利ではあるが、運用する場所によっては必要のない処理も含まれている。 例えば、新規アカウント作成の処理。これは限られた人間しかアクセスを許されないサイト(例:社員用のウェブアプリ等)の場合、部外者が勝手にアカウントを作り、内部へのアクセスを許してしまう。 そこで、新規アカウント作成処理やパスワード変更処理などを無効化させる。そのためには、allauthのurls.p</description>
    </item>
    
    <item>
      <title>【Django】バッチ処理でPS、AI(PDF)ファイルのサムネイルを自動生成させる【BaseCommand】</title>
      <link>https://noauto-nolife.com/post/django-batch-thumbnail-create/</link>
      <pubDate>Sun, 23 May 2021 12:02:33 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-batch-thumbnail-create/</guid>
      <description>PS、AIファイルのサムネイルを作る処理をmanage.pyコマンドに追加することで、ビューの負担を軽減する。 これにより、負荷のかかる処理をビューから分離できる。投稿処理が集中しても、高負荷の処理が原因でサーバーダウンすることは無いのだ。 全体像 こんなふうに、通常のリクエストで行われる処理系とは分離して、サムネイルの自動生成が行われる。 ループにより逐次処理を行うため、リクエストとは違って並列ではない</description>
    </item>
    
    <item>
      <title>【Django】16進カラーコードから色名に書き換えるフィルタを自作する【カスタムテンプレートフィルタ】</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags-color/</link>
      <pubDate>Wed, 12 May 2021 17:35:56 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags-color/</guid>
      <description>models.pyにて、色の指定を16進数のカラーコードで受け入れる。その16進数カラーコードを、色名(orangeとかforestgreenとか)に書き換える。 そういうカスタムテンプレートフィルタを自作する方法を解説する。 models.pyのカラーコード受け入れ from django.db import models from django.core.validators import RegexValidator &amp;quot;&amp;quot;&amp;quot; 省略 &amp;quot;&amp;quot;&amp;quot; color_regex = RegexValidator(regex=r&#39;^#(?:[0-9a-fA-F]{3}){1,2}$&#39;) color = models.CharField(verbose_name=&amp;quot;リボン色&amp;quot;,max_</description>
    </item>
    
    <item>
      <title>Djangoでアップロードされた.aiと.psファイルのサムネイルを自動生成させる【PhotoShop,Illustrator】</title>
      <link>https://noauto-nolife.com/post/django-aips-thumbnail-autocreate/</link>
      <pubDate>Mon, 10 May 2021 10:01:41 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-aips-thumbnail-autocreate/</guid>
      <description>ファイルをアップロードした後、ファイル名だけ表示されている状態では、それが何なのかパット見でよくわからない。 だからこそ、事前にサムネイルを用意させる。こんなふうに だが、サムネイル画像のアップロードまでユーザーに押し付けるのは、気軽なファイル共有を前提としたウェブアプリのコンセプトが台無しになる。そこで、アップロードしたファイルのサムネイルをサーバーサイドに自動生成してもらう。 本記事ではファイルアッ</description>
    </item>
    
    <item>
      <title>【django.core.paginator】一度に2ページ以上ジャンプできるように改良する【inclusion_tag()】</title>
      <link>https://noauto-nolife.com/post/django-paginator-custom/</link>
      <pubDate>Fri, 07 May 2021 09:50:13 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-paginator-custom/</guid>
      <description>以前のページネーション実装記事では、検索とページのパラメーターの両立を行った。 しかし、このページネーションは1ページずつしか移動できない。つまり、1ページ目の状態から2ページ目に行くことはできても、3ページ目にジャンプすることはできないのだ。 そこでページネーションを改良させ、一度に2ページ以上ジャンプできるように改良する。 やりたいことと方法論の解説 やりたいこと 要するに、本記事でやりたいのはこういう</description>
    </item>
    
    <item>
      <title>Djangoでviews.pyからmodels.pyのフィールドオプションを参照する【verbose_name,upload_to】</title>
      <link>https://noauto-nolife.com/post/django-reference-models-option/</link>
      <pubDate>Tue, 04 May 2021 20:30:19 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-reference-models-option/</guid>
      <description>需要ないかもだけど、備忘録として。 Video.thumbnail.field.upload_to つまり、 [モデルクラス].[フィールド名].field.[フィールドオプション] これで参照できる。 用途 FileFieldでアップロードした動画のサムネイル(ImageField)をviews.pyが自動生成する時、アップロード先のパスを指定する必要があるが、models.pyのフィールドオプションとして書いたupload_toと整合性を合わせるために、本記事で扱</description>
    </item>
    
    <item>
      <title>【Slack風】モーダルダイアログ無し、ページ遷移無しで編集フォームを作る【JS不使用】</title>
      <link>https://noauto-nolife.com/post/nomodal-edit-form/</link>
      <pubDate>Sun, 25 Apr 2021 13:42:24 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/nomodal-edit-form/</guid>
      <description>投稿されたコンテンツを編集する時、編集フォームを表示するページに遷移したり、編集フォームをJSなどを使用してモーダルダイアログとして表示させることがある。こんなふうに。 しかし、これでは他のコンテンツを見ながらの編集ができない。それだけでなく、ページ遷移やダイアログ表示を行うとJSやサーバーサイドに負担がかかる。そこで、投稿したコンテンツを表示する場所を、編集フォームに切り替えるように仕立てる。こん</description>
    </item>
    
    <item>
      <title>【Django】バッチ処理のOpenCVが撮影した画像をDBに保存する</title>
      <link>https://noauto-nolife.com/post/django-batch-opencv/</link>
      <pubDate>Tue, 16 Mar 2021 16:15:03 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-batch-opencv/</guid>
      <description>Djangoのバッチ処理を実行し、DBにデータを格納させる。ただし、OpenCVで撮影した画像をDBに保存させる。本記事ではその手順を記す。 実行環境・やりたいこと 実行環境 Django 2.2以上 Ubuntu 18.04 やりたいこと 流れはだいたいこんな感じ OS起動時、バッチ処理がCrontabから実行される バッチ処理はOpenCVを使用し、撮影した画像を保存 保存した画像とコメントをDBに記録 1秒経ったら、2に戻る つまり、コマ撮りし</description>
    </item>
    
    <item>
      <title>Djangoで動画投稿時にサムネイルもセットでアップロードする【DRF&#43;Ajax(jQuery)&#43;canvas】</title>
      <link>https://noauto-nolife.com/post/django-ajax-thumbnail-upload/</link>
      <pubDate>Mon, 01 Mar 2021 15:03:31 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax-thumbnail-upload/</guid>
      <description>Djangoで動画をアップロードする時、ffmpegなどを使ってサムネイルの自動生成を行うが、クライアントが自分で動画のサムネイルを指定したいときはこの限りではない。 サムネイルに指定したい画像は動画内にあり、クライアントがサムネイルの画像をまだ作っていない場合、アップロードフォームでサムネイルを作る必要がある。 本記事では動画を投稿する際、サムネイルをクライアントが指定した上でアップロードする手法を</description>
    </item>
    
    <item>
      <title>Djangoでカスタムユーザーモデルを外部キーとして指定する方法【1対多】</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-foreignkey/</link>
      <pubDate>Sat, 20 Feb 2021 11:13:37 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-foreignkey/</guid>
      <description>例えば、簡易掲示板で投稿者のユーザーIDを外部キーとして指定したい場合がある。 作ったカスタムユーザーモデルを外部キーとして通常のアプリから指定する方法を解説する。 本記事では、下記記事で解説したカスタムユーザーモデルを実装したことを前提として話を進める。 【Django】allauthとカスタムユーザーモデルを実装した簡易掲示板を作る【AbstrastBaseUser】 カスタムユーザーモデルを外部キー</description>
    </item>
    
    <item>
      <title>DjangoでUUIDを主キーとし、first_nameとlast_nameを1つにまとめたカスタムユーザーモデルを作る【AbstractBaseUserとallauth】</title>
      <link>https://noauto-nolife.com/post/django-custom-user-model-uuid/</link>
      <pubDate>Mon, 15 Feb 2021 15:47:57 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-user-model-uuid/</guid>
      <description>Djangoでユーザーを作ったとき、デフォルトでは数値型オートインクリメントの主キーになる。 身内だけで使う小さなウェブアプリであれば大した問題にはならないと思うが、基本主キーが数値型かつオートインクリメントであれば、簡単に予測されてしまう。セキュリティリスクは最小限に留めるためにも、なるべく主キーはUUID型にしたい。 そこで、本記事ではユーザーの主キーにUUIDを使用したカスタムユーザーモデルの作</description>
    </item>
    
    <item>
      <title>【Django】manage.pyコマンドを追加させる【バッチ処理、常駐プログラムなどに】</title>
      <link>https://noauto-nolife.com/post/django-command-add/</link>
      <pubDate>Mon, 01 Feb 2021 18:25:13 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-command-add/</guid>
      <description>Djangoのmanage.pyにはコマンドを追加することができる。これを利用すれば、アプリディレクトリで定義したモデルをそのまま流用してDBにアクセスしたり、コマンド一発で複雑な処理を終わらせたり、バッチ処理として運用させることも簡単にできる。 manage.pyにコマンドを追加させる まず、任意のアプリディレクトリにmanagement/commands/ディレクトリを作る。 mkdir -p [アプリディレクト</description>
    </item>
    
    <item>
      <title>【Django】外部キーに対応したデータの個数をカウントして表示【リプライ・コメント数の表示に有効】【annotate&#43;Count】</title>
      <link>https://noauto-nolife.com/post/django-foreign-count/</link>
      <pubDate>Tue, 26 Jan 2021 17:02:16 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-foreign-count/</guid>
      <description>例えば、Djangoで掲示板サイトを作り、投稿した内容に対してリプライできる機能を付けたとする。そのリプライ数を一覧表示時に合わせて表示させる時、どうする？ 本記事では、上記のように一対多のリレーションが構築されている環境下で、多に該当するデータ数を計算して表示させる方法を解説する。 多のデータ数を計算してそれぞれ表示させる 下記のような、Topicに対してReplyができるモデルになっていたとする。 from</description>
    </item>
    
    <item>
      <title>【Django】モデルフィールドに正規表現によるバリデーションを指定する【カラーコード・電話番号に有効】</title>
      <link>https://noauto-nolife.com/post/django-models-regex-validate/</link>
      <pubDate>Tue, 26 Jan 2021 16:40:18 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-models-regex-validate/</guid>
      <description>例えば、Djangoで電話番号や16進数カラーコード、郵便番号や金融機関コードなどの、桁数と使用文字の種類が決まったデータをモデルフィールドに挿入する時、どうしていますか？ CharFieldやIntegerFieldにそのまま入れる？フロント側で対策しているから大丈夫？そんなわけない。不適切なデータがDBに入った時点で、システムは破綻する。それは世の常。 そこで、本記事ではモデルに正規表現のバリデー</description>
    </item>
    
    <item>
      <title>Djangoで埋め込みカスタムテンプレートタグを実装する方法</title>
      <link>https://noauto-nolife.com/post/django-custom-template-tags/</link>
      <pubDate>Tue, 26 Jan 2021 15:55:04 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-custom-template-tags/</guid>
      <description>Djangoでデータの値に応じて文字列を返したい場合は、カスタムテンプレートタグを使用すれば良い。下記記事は、ページ移動と検索を両立させるため、文字列を返す、カスタムテンプレートタグを実装している。 Djangoでページネーションを実装する方法【django.core.paginator】【パラメータ両立】 しかし、データの値に応じてHTMLタグを返却するには、上記の方法では成立しない。safeフィル</description>
    </item>
    
    <item>
      <title>Djangoにカスタムユーザーモデルを実装させる【AbstractUserとallauth】</title>
      <link>https://noauto-nolife.com/post/django-allauth-custom-user-model/</link>
      <pubDate>Mon, 14 Dec 2020 16:28:15 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-allauth-custom-user-model/</guid>
      <description>Djangoでカスタムユーザーモデルを実装すれば、ユーザーが会員登録をする時、IDとパスワードだけでなく、ファーストネームや年齢、職業なども入力させた上で会員登録を行うことができる。 これにより、会員登録した後、データ投稿時にユーザー情報もセットで挿入できる。未指定でログイン可能な会員になってしまうという問題を防ぐことができる。 ただ、カスタムユーザーモデルの実装は容易ではない。カスタムユーザーモデル</description>
    </item>
    
    <item>
      <title>Djangoで多対多のリレーションを含むデータをAjax(jQuery)&#43;DRFで送信させる</title>
      <link>https://noauto-nolife.com/post/django-m2m-restful/</link>
      <pubDate>Tue, 01 Dec 2020 17:17:52 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-restful/</guid>
      <description>本記事では多対多のリレーションを含んだウェブアプリで、Django REST FrameworkとAjaxを使用した非同期データ送信を実現させる方法を書く。 ソースコードは『【Django】一対多、多対多のリレーションでforms.pyを使ったバリデーションとフォームを表示』の『【2】forms.pyを使用したフォームバリデーション+独自に作ったテンプレート』から流用した。 Ajax(jQuery)+Restf</description>
    </item>
    
    <item>
      <title>DRF(Django REST Framework)&#43;Ajax(jQuery)で画像とファイルをアップロードする方法</title>
      <link>https://noauto-nolife.com/post/drf-ajax-fileupload/</link>
      <pubDate>Tue, 01 Dec 2020 17:06:20 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/drf-ajax-fileupload/</guid>
      <description>本記事では、DRF(Django REST Framework)とAjaxを使用して画像とファイルを非同期でアップロードする方法をまとめる。 コードはDjangoで画像及びファイルをアップロードする方法から引用している。外見はほとんど変わっていない。 テンプレートとJSのコード まずテンプレート。下記はimage.html {% load static %} &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt; &amp;lt;title&amp;gt;画像アップロードのテスト&amp;lt;/ti</description>
    </item>
    
    <item>
      <title>【Django】一対多、多対多のリレーションでforms.pyを使ったバリデーションとフォームを表示</title>
      <link>https://noauto-nolife.com/post/django-m2m-form/</link>
      <pubDate>Tue, 01 Dec 2020 16:03:44 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-m2m-form/</guid>
      <description>本記事ではDjangoで一対多、多対多のリレーションを実装した上で、forms.pyを使用し、フォームをバリデーションする。 また、単にforms.pyからフォームのテンプレートを作るだけでなく、複数指定が要求されるフォームの作り方についても解説する。 コードはDjangoで多対多のリレーションをテンプレートで表示する方法【ManyToManyField】から流用。 【1】forms.pyを使用したフォ</description>
    </item>
    
    <item>
      <title>【Restful】DjangoでAjax(jQuery)を実装する方法【Django REST Framework使用】</title>
      <link>https://noauto-nolife.com/post/django-ajax-restful/</link>
      <pubDate>Tue, 10 Nov 2020 14:01:19 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/django-ajax-restful/</guid>
      <description>先日の記事にて、DjangoでAjax(jQuery)を実装する方法を解説した。 ただ、RestfulAPIを使用すれば、さらに少ないコードでAjaxを実装することができる。 RestfulAPI、Django REST Frameworkとは RestfulAPIとは、HTTPリクエストに応じてサーバーの処理を切り分けることができるAPIのこと。 HTTPリクエストのヘッダ部には、リクエスト送信先のURLとリクエ</description>
    </item>
    
    <item>
      <title>【地理空間情報】GeoDjangoの実装方法【PostGIS&#43;PostgreSQL&#43;国土地理院データ】</title>
      <link>https://noauto-nolife.com/post/startup-geodjango/</link>
      <pubDate>Wed, 21 Oct 2020 16:46:02 +0900</pubDate>
      
      <guid>https://noauto-nolife.com/post/startup-geodjango/</guid>
      <description>圧倒的に日本語の情報、及びソースコードが不足しているgeodjangoについてまとめています。(勉強してすぐにまとめているので、多少間違いがあるかも。) Ubuntu 18.04 LTS にて動作確認済み。 流れ Djangoのインストール PostgreSQLのインストール GEOS、GDAL、PROJ4、PostGISのインストール プロジェクトの作成 アプリの作成 settings.pyの書き換え models.pyの書き換え 国土交通省</description>
    </item>
    
  </channel>
</rss>